/*
 * Copyright 2025 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:OptIn(InternalComposeApi::class)
@file:Suppress("NOTHING_TO_INLINE", "KotlinRedundantDiagnosticSuppress")

package androidx.compose.runtime

import androidx.collection.MutableIntIntMap
import androidx.collection.MutableIntObjectMap
import androidx.collection.MutableScatterMap
import androidx.collection.MutableScatterSet
import androidx.collection.ScatterSet
import androidx.collection.mutableScatterSetOf
import androidx.compose.runtime.changelist.ChangeList
import androidx.compose.runtime.changelist.ComposerChangeListWriter
import androidx.compose.runtime.changelist.FixupList
import androidx.compose.runtime.collection.MultiValueMap
import androidx.compose.runtime.collection.ScopeMap
import androidx.compose.runtime.internal.IntRef
import androidx.compose.runtime.internal.invokeComposable
import androidx.compose.runtime.internal.persistentCompositionLocalHashMapOf
import androidx.compose.runtime.internal.trace
import androidx.compose.runtime.snapshots.currentSnapshot
import androidx.compose.runtime.snapshots.fastForEach
import androidx.compose.runtime.snapshots.fastToSet
import androidx.compose.runtime.tooling.ComposeStackTraceFrame
import androidx.compose.runtime.tooling.CompositionData
import androidx.compose.runtime.tooling.CompositionErrorContextImpl
import androidx.compose.runtime.tooling.LocalCompositionErrorContext
import androidx.compose.runtime.tooling.LocalInspectionTables
import androidx.compose.runtime.tooling.attachComposeStackTrace
import androidx.compose.runtime.tooling.buildTrace
import androidx.compose.runtime.tooling.findLocation
import androidx.compose.runtime.tooling.findSubcompositionContextGroup
import androidx.compose.runtime.tooling.traceForGroup
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext

private class GroupInfo(
  /**
   * The current location of the slot relative to the start location of the pending slot changes
   */
  var slotIndex: Int,

  /**
   * The current location of the first node relative the start location of the pending node
   * changes
   */
  var nodeIndex: Int,

  /** The current number of nodes the group contains after changes have been applied */
  var nodeCount: Int,
)

/**
 * Pending starts when the key is different than expected indicating that the structure of the tree
 * changed. It is used to determine how to update the nodes and the slot table when changes to the
 * structure of the tree is detected.
 *
 * 예상된 키와 다를 때, 즉 트리의 구조가 변경되었음을 나타낼 때 보류 상태가 시작됩니다. 이는 트리
 * 구조의 변경이 감지되었을 때 노드와 슬롯 테이블을 어떻게 갱신할지 결정하는 데 사용됩니다.
 */
private class Pending(val keyInfos: MutableList<KeyInfo>, val startIndex: Int) {
  var groupIndex: Int = 0

  init {
    requirePrecondition(startIndex >= 0) { "Invalid start index" }
  }

  private val usedKeys = mutableListOf<KeyInfo>()
  private val groupInfos = run {
    var runningNodeIndex = 0
    val result = MutableIntObjectMap<GroupInfo>()
    for (index in 0 until keyInfos.size) {
      val keyInfo = keyInfos[index]
      result[keyInfo.location] = GroupInfo(index, runningNodeIndex, keyInfo.nodes)
      runningNodeIndex += keyInfo.nodes
    }
    result
  }

  /**
   * A multi-map of keys from the previous composition. The keys can be retrieved in the order
   * they were generated by the previous composition.
   */
  val keyMap by lazy {
    multiMap<Any, KeyInfo>(keyInfos.size).also {
      for (index in 0 until keyInfos.size) {
        val keyInfo = keyInfos[index]
        it.add(keyInfo.joinedKey, keyInfo)
      }
    }
  }

  /**
   * Get the next key information for the given key.
   *
   * 주어진 키의 다음 키 정보를 가져옵니다.
   */
  fun getNext(key: Int, dataKey: Any?): KeyInfo? {
    val joinedKey: Any = if (dataKey != null) JoinedKey(left = key, right = dataKey) else key
    return keyMap.removeFirst(key = joinedKey)
  }

  /** Record that this key info was generated. */
  fun recordUsed(keyInfo: KeyInfo): Boolean = usedKeys.add(keyInfo)

  val used: List<KeyInfo>
    get() = usedKeys

  // TODO(chuckj): This is a correct but expensive implementation (worst cases of O(N^2)). Rework
  // to O(N)
  fun registerMoveSlot(from: Int, to: Int) {
    if (from > to) {
      groupInfos.forEachValue { group ->
        val position = group.slotIndex
        if (position == from) group.slotIndex = to
        else if (position in to until from) group.slotIndex = position + 1
      }
    } else if (to > from) {
      groupInfos.forEachValue { group ->
        val position = group.slotIndex
        if (position == from) group.slotIndex = to
        else if (position in (from + 1) until to) group.slotIndex = position - 1
      }
    }
  }

  fun registerMoveNode(from: Int, to: Int, count: Int) {
    if (from > to) {
      groupInfos.forEachValue { group ->
        val position = group.nodeIndex
        if (position in from until from + count) group.nodeIndex = to + (position - from)
        else if (position in to until from) group.nodeIndex = position + count
      }
    } else if (to > from) {
      groupInfos.forEachValue { group ->
        val position = group.nodeIndex
        if (position in from until from + count) group.nodeIndex = to + (position - from)
        else if (position in (from + 1) until to) group.nodeIndex = position - count
      }
    }
  }

  @OptIn(InternalComposeApi::class)
  fun registerInsert(keyInfo: KeyInfo, insertIndex: Int) {
    groupInfos[keyInfo.location] = GroupInfo(-1, insertIndex, 0)
  }

  fun updateNodeCount(group: Int, newCount: Int): Boolean {
    val groupInfo = groupInfos[group]
    if (groupInfo != null) {
      val index = groupInfo.nodeIndex
      val difference = newCount - groupInfo.nodeCount
      groupInfo.nodeCount = newCount
      if (difference != 0) {
        groupInfos.forEachValue { childGroupInfo ->
          if (childGroupInfo.nodeIndex >= index && childGroupInfo != groupInfo) {
            val newIndex = childGroupInfo.nodeIndex + difference
            if (newIndex >= 0) childGroupInfo.nodeIndex = newIndex
          }
        }
      }
      return true
    }
    return false
  }

  @OptIn(InternalComposeApi::class)
  fun slotPositionOf(keyInfo: KeyInfo): Int = groupInfos[keyInfo.location]?.slotIndex ?: -1

  @OptIn(InternalComposeApi::class)
  fun nodePositionOf(keyInfo: KeyInfo): Int = groupInfos[keyInfo.location]?.nodeIndex ?: -1

  @OptIn(InternalComposeApi::class)
  fun updatedNodeCountOf(keyInfo: KeyInfo): Int =
    groupInfos[keyInfo.location]?.nodeCount ?: keyInfo.nodes
}

private class Invalidation(
  /**
   * The recompose scope being invalidate.
   *
   * 무효화되고 있는 리컴포즈 스코프입니다.
   */
  val scope: RecomposeScopeImpl,

  /**
   * The index of the group in the slot table being invalidated.
   *
   * 무효화되고 있는 슬롯 테이블 내 그룹의 인덱스입니다.
   **/
  var location: Int,

  /**
   * The instances invalidating the scope. If this is `null` or empty then the scope is
   * unconditionally invalid. If it contains instances it is only invalid if at least on of the
   * instances is changed. This is used to track `DerivedState<*>` changes and only treat the
   * scope as invalid if the instance has changed.
   *
   * Can contain a [ScatterSet] of instances, single instance or null.
   *
   *
   * 스코프를 무효화하는 인스턴스들입니다. 값이 null이거나 비어 있으면 스코프는 무조건
   * 무효가 됩니다. 인스턴스를 포함하고 있으면 그중 하나라도 변경된 경우에만 무효로 간주됩니다.
   * 이는 `DerivedState<*>` 변경을 추적하고, 인스턴스가 실제로 바뀌었을 때만 스코프를 무효로
   * 처리하기 위해 사용됩니다.
   *
   * [ScatterSet] 형태의 인스턴스 집합, 단일 인스턴스, 또는 null을 가질 수 있습니다.
   */
  var instances: Any?,
) {
  fun isInvalid(): Boolean = scope.isInvalidFor(instances = instances)
}

/** Implementation of a composer for a mutable tree. */
@OptIn(ExperimentalComposeRuntimeApi::class)
internal class ComposerImpl(
  /** An adapter that applies changes to the tree using the Applier abstraction. */
  override val applier: Applier<*>,

  /** Parent of this composition; a [Recomposer] for root-level compositions. */
  private val parentContext: CompositionContext,

  /** The slot table to use to store composition data */
  private val slotTable: SlotTable,
  private val abandonSet: MutableSet<RememberObserver>,
  private var changes: ChangeList,
  private var lateChanges: ChangeList,
  private val observerHolder: CompositionObserverHolder,

  /** The composition that owns this composer */
  override val composition: CompositionImpl,
) : Composer {
  private val pendingStack = Stack<Pending?>()
  private var pending: Pending? = null
  private var nodeIndex: Int = 0
  private var groupNodeCount: Int = 0
  // MEMO rGroup is readGroup ????
  private var rGroupIndex: Int = 0
  private val parentStateStack = IntStack()
  private var nodeCountOverrides: IntArray? = null
  private var nodeCountVirtualOverrides: MutableIntIntMap? = null
  private var forceRecomposeScopes = false
  private var forciblyRecompose = false
  private var nodeExpected = false
  private val invalidations: MutableList<Invalidation> = mutableListOf()
  private val entersStack = IntStack()
  private var rootProvider: PersistentCompositionLocalMap = persistentCompositionLocalHashMapOf()
  private var providerUpdates: MutableIntObjectMap<PersistentCompositionLocalMap>? = null
  private var providersInvalid = false
  private val providersInvalidStack = IntStack()
  private var reusing = false
  private var reusingGroup = -1
  private var childrenComposing: Int = 0
  private var compositionToken: Int = 0

  private var sourceMarkersEnabled =
    parentContext.collectingSourceInformation || parentContext.collectingCallByInformation

  private val derivedStateObserver =
    object : DerivedStateObserver {
      override fun start(derivedState: DerivedState<*>) {
        childrenComposing++
      }

      override fun done(derivedState: DerivedState<*>) {
        childrenComposing--
      }
    }

  private val invalidateStack = Stack<RecomposeScopeImpl>()

  internal var isComposing = false
    private set

  internal var isDisposed = false
    private set

  internal val areChildrenComposing
    get() = childrenComposing > 0

  internal val hasPendingChanges: Boolean
    get() = changes.isNotEmpty()

  internal var reader: SlotReader = slotTable.openReader().also { it.close() }

  internal var insertTable =
    SlotTable().apply {
      if (parentContext.collectingSourceInformation) collectSourceInformation()
      if (parentContext.collectingCallByInformation) collectCalledByInformation()
    }

  private var writer: SlotWriter = insertTable.openWriter().also { it.close(normalClose = true) }
  private var writerHasAProvider = false
  private var providerCache: PersistentCompositionLocalMap? = null
  internal var deferredChanges: ChangeList? = null

  private val changeListWriter = ComposerChangeListWriter(this, changes)
  private var insertAnchor: Anchor = insertTable.read { it.anchor(0) }
  private var insertFixups = FixupList()

  private var pausable: Boolean = false
  private var shouldPauseCallback: ShouldPauseCallback? = null

  internal val errorContext: CompositionErrorContextImpl? = CompositionErrorContextImpl(this)
    get() = if (sourceMarkersEnabled) field else null

  override val applyCoroutineContext: CoroutineContext =
    parentContext.effectCoroutineContext + (errorContext ?: EmptyCoroutineContext)

  /**
   * Inserts a "Replaceable Group" starting marker in the slot table at the current execution
   * position. A Replaceable Group is a group which cannot be moved between its siblings, but can
   * be removed or inserted. These groups are inserted by the compiler around branches of
   * conditional logic in Composable functions such as if expressions, when expressions, early
   * returns, and null-coalescing operators.
   *
   * A call to [startReplaceableGroup] must be matched with a corresponding call to
   * [endReplaceableGroup].
   *
   * Warning: Versions of the compiler that generate calls to this function also contain subtle
   * bug that does not generate a group around a loop containing code that just creates composable
   * lambdas (AnimatedContent from androidx.compose.animation, for example) which makes replacing
   * the group unsafe and the this must treat this like a movable group. [startReplaceGroup] was
   * added that will replace the group as described above and is only called by versions of the
   * compiler that correctly generate code around loops that create lambdas.
   *
   * Warning: This is expected to be executed by the compiler only and should not be called
   * directly from source code. Call this API at your own risk.
   *
   * @param key The source-location-based key for the group. Expected to be unique among its
   *   siblings.
   * @see [endReplaceableGroup]
   * @see [startMovableGroup]
   * @see [startRestartGroup]
   *
   *
   * 슬롯 테이블의 현재 실행 위치에 “Replaceable Group” 시작 마커를 삽입합니다. Replaceable Group은
   * 형제 그룹 사이에서 이동할 수는 없지만 제거하거나 삽입할 수 있는 그룹입니다. 이러한 그룹은
   * 컴파일러가 if 표현식, when 표현식, 조기 반환, null 병합 연산자 같은 Composable 함수의 조건
   * 분기 주위에 삽입합니다.
   *
   * [startReplaceableGroup] 호출은 반드시 대응하는 [endReplaceableGroup] 호출로 닫혀야 합니다.
   *
   * 경고: 이 함수를 호출하는 코드를 생성하는 컴파일러 버전에는, 컴포저블 람다만 생성하는 루프
   * (예: androidx.compose.animation.AnimatedContent)를 그룹으로 감싸지 않는 버그가 있습니다.
   * 이 경우 그룹을 교체하는 것이 안전하지 않으므로, 이를 Movable Group처럼 다뤄야 합니다. 이 문제를
   * 해결하기 위해 [startReplaceGroup]이 추가되었으며, 람다를 생성하는 루프 주위에 올바르게 코드를
   * 생성하는 컴파일러 버전에서만 호출됩니다.
   *
   * 경고: 이 함수는 오직 컴파일러에 의해 실행되는 것을 전제로 하며, 소스 코드에서 직접 호출해서는
   * 안 됩니다. 직접 사용할 경우 위험을 감수해야 합니다.
   *
   * @param key 그룹의 소스 위치 기반 키. 형제 그룹 사이에서 고유해야 합니다.
   */
  @ComposeCompilerApi
  override fun startReplaceableGroup(key: Int) {
    start(
      key = key,
      objectKey = null,
      kind = GroupKind.Group,
      data = null,
    )
  }

  /**
   * Indicates the end of a "Replaceable Group" at the current execution position. A Replaceable
   * Group is a group which cannot be moved between its siblings, but can be removed or inserted.
   * These groups are inserted by the compiler around branches of conditional logic in Composable
   * functions such as if expressions, when expressions, early returns, and null-coalescing
   * operators.
   *
   * Warning: This is expected to be executed by the compiler only and should not be called
   * directly from source code. Call this API at your own risk.
   *
   * @see [startReplaceableGroup]
   *
   *
   * 현재 실행 위치에서 “Replaceable Group”의 끝을 나타냅니다. Replaceable Group은 형제 그룹 사이에서
   * 이동할 수는 없지만 제거하거나 삽입할 수 있는 그룹입니다. 이러한 그룹은 컴파일러가 if 표현식,
   * when 표현식, 조기 반환, null 병합 연산자 같은 Composable 함수의 조건 분기 주위에 삽입합니다.
   *
   * 경고: 이 함수는 오직 컴파일러에 의해 실행되는 것을 전제로 하며, 소스 코드에서 직접 호출해서는
   * 안 됩니다. 직접 사용할 경우 위험을 감수해야 합니다.
   *
   * @see [startReplaceableGroup]
   */
  @ComposeCompilerApi
  override fun endReplaceableGroup() {
    endGroup()
  }

  /**
   * Start a replace group. A replace group is a group that cannot be moved during must only
   * either be inserted, removed, or replaced. For example, the group created by most control flow
   * constructs such as an `if` statement are replaceable groups.
   *
   * Note: This method replaces [startReplaceableGroup] which is only generated by older versions
   * of the compose compiler plugin that predate the addition of this method. The runtime is now
   * required to replace the group if a different group is detected instead of treating it like a
   * movable group.
   *
   * @param key A compiler generated key based on the source location of the call.
   *
   *
   * replace 그룹을 시작합니다. replace 그룹은 이동할 수 없으며 삽입, 제거, 교체만 가능합니다. 예를
   * 들어, if 문과 같은 대부분의 제어 흐름 구조가 생성하는 그룹은 replaceable 그룹입니다.
   *
   * 참고: 이 메서드는 [startReplaceableGroup]을 대체합니다. [startReplaceableGroup]은 이 메서드가
   * 추가되기 이전의 구버전 Compose 컴파일러 플러그인에서만 생성됩니다. 이제 런타임은 다른 그룹이
   * 감지되면 그것을 movable group처럼 취급하지 않고 반드시 교체해야 합니다.
   *
   * @param key 호출 소스 위치를 기반으로 컴파일러가 생성한 키입니다.
   */
  @ComposeCompilerApi
  override fun startReplaceGroup(key: Int) {
    val pending = pending
    if (pending != null) {
      return start(
        key = key,
        objectKey = null,
        kind = GroupKind.Group,
        data = null,
      )
    }

    validateNodeNotExpected()

    updateCompositeKeyWhenWeEnterGroup(
      groupKey = key,
      rGroupIndex = rGroupIndex,
      dataKey = null,
      data = null,
    )

    rGroupIndex++

    val reader = reader

    if (inserting) {
      reader.beginEmpty()
      writer.startGroup(key = key, dataKey = Composer.Empty)
      enterGroup(isNode = false, newPending = null)
      return
    }

    val slotKey = reader.groupKey

    if (slotKey == key && !reader.hasObjectKey) {
      reader.startGroup()
      enterGroup(isNode = false, newPending = null)
      return
    }

    if (!reader.isGroupEnd) {
      // Delete the group that was not expected.
      // 예상되지 않은 그룹을 삭제합니다.
      val removeIndex = nodeIndex
      val startSlot = reader.currentGroup

      recordDelete()

      val nodesToRemove = reader.skipGroup()

      changeListWriter.removeNode(nodeIndex = removeIndex, count = nodesToRemove)
      invalidations.removeRange(start = startSlot, end = reader.currentGroup)
    }

    // Insert the new group.
    // 새 그룹을 삽입합니다.
    reader.beginEmpty()

    inserting = true
    providerCache = null

    ensureWriter()

    val writer = writer
    writer.beginInsert()

    val startIndex = writer.currentGroup
    writer.startGroup(key = key, dataKey = Composer.Empty)

    insertAnchor = writer.anchor(index = startIndex)

    enterGroup(isNode = false, newPending = null)
  }

  /**
   * Called at the end of a replace group.
   *
   * replace 그룹의 끝에서 호출됩니다.
   */
  @ComposeCompilerApi override fun endReplaceGroup() {
    endGroup()
  }

  /**
   * Called to start the group that calculates the default parameters of a [Composable] function.
   *
   * This method is called near the beginning of a [Composable] function with default parameters
   * and surrounds the remembered values or [Composable] calls necessary to produce the default
   * parameters. For example, for `model: Model = remember { DefaultModel() }` the call to
   * [remember] is called inside a [startDefaults] group.
   *
   *
   * [Composable] 함수의 기본 매개변수를 계산하는 그룹을 시작할 때 호출됩니다.
   *
   * 이 메서드는 기본 매개변수가 있는 [Composable] 함수의 시작 부분 근처에서 호출되며, 기본
   * 매개변수를 생성하는 데 필요한 remember된 값이나 [Composable] 호출을 감쌉니다. 예를 들어
   * `model: Model = remember { DefaultModel() }`의 경우, [remember] 호출은 [startDefaults] 그룹
   * 내부에서 호출됩니다.
   */
  @ComposeCompilerApi
  override fun startDefaults() {
    start(
      key = defaultsKey,
      objectKey = null,
      kind = GroupKind.Group,
      data = null,
    )
  }

  /**
   * Called at the end of defaults group.
   *
   * defaults 그룹의 끝에서 호출됩니다.
   *
   * @see [startReplaceableGroup]
   */
  @ComposeCompilerApi
  override fun endDefaults() {
    endGroup()

    val scope = currentRecomposeScope
    if (scope != null && scope.used) {
      scope.defaultsInScope = true
    }
  }

  @Suppress("unused")
  override val defaultsInvalid: Boolean
    get() =
      !skipping ||
        providersInvalid ||
        currentRecomposeScope?.defaultsInvalid == true

  /**
   * Inserts a "Movable Group" starting marker in the slot table at the current execution
   * position. A Movable Group is a group which can be moved or reordered between its siblings and
   * retain slot table state, in addition to being removed or inserted. Movable Groups are more
   * expensive than other groups because when they are encountered with a mismatched key in the
   * slot table, they must be held on to temporarily until the entire parent group finishes
   * execution in case it moved to a later position in the group. Movable groups are only inserted
   * by the compiler as a result of calls to [key].
   *
   * A call to [startMovableGroup] must be matched with a corresponding call to [endMovableGroup].
   *
   * Warning: This is expected to be executed by the compiler only and should not be called
   * directly from source code. Call this API at your own risk.
   *
   * @param key The source-location-based key for the group. Expected to be unique among its
   *   siblings.
   * @param dataKey Additional identifying information to compound with [key]. If there are
   *   multiple values, this is expected to be compounded together with [joinKey]. Whatever value
   *   is passed in here is expected to have a meaningful [equals] and [hashCode] implementation.
   * @see [endMovableGroup]
   * @see [key]
   * @see [joinKey]
   * @see [startReplaceableGroup]
   * @see [startRestartGroup]
   *
   *
   * 슬롯 테이블의 현재 실행 위치에 “Movable Group” 시작 마커를 삽입합니다. Movable Group은 형제
   * 그룹 사이에서 이동하거나 순서를 바꾸더라도 슬롯 테이블 상태를 유지할 수 있으며, 제거하거나
   * 삽입할 수도 있는 그룹입니다. 다만 Movable Group은 다른 그룹보다 비용이 더 큰데, 슬롯 테이블에서
   * 키가 일치하지 않는 경우 나중에 부모 그룹 실행이 끝날 때까지 해당 그룹이 이동했는지를 확인하기
   * 위해 임시로 유지해야 하기 때문입니다. Movable Group은 컴파일러가 [key] 호출의 결과로만 삽입합니다.
   *
   * [startMovableGroup] 호출은 반드시 대응하는 [endMovableGroup] 호출로 닫혀야 합니다.
   *
   * 경고: 이 함수는 오직 컴파일러에 의해 실행되는 것을 전제로 하며, 소스 코드에서 직접 호출해서는
   * 안 됩니다. 직접 사용할 경우 위험을 감수해야 합니다.
   *
   * @param key 그룹의 소스 위치 기반 키. 형제 그룹 사이에서 고유해야 합니다.
   * @param dataKey [key]와 합쳐서 식별을 강화하는 추가 정보. 값이 여러 개일 경우 [joinKey]로 합쳐야
   *  합니다. 전달된 값은 의미 있는 [equals]와 [hashCode] 구현을 가져야 합니다.
   */
  @ComposeCompilerApi
  override fun startMovableGroup(key: Int, dataKey: Any?) {
    start(
      key = key,
      objectKey = dataKey,
      kind = GroupKind.Group,
      data = null,
    )
  }

  /**
   * Indicates the end of a "Movable Group" at the current execution position. A Movable Group is
   * a group which can be moved or reordered between its siblings and retain slot table state, in
   * addition to being removed or inserted. These groups are only valid when they are inserted as
   * direct children of Container Groups. Movable Groups are more expensive than other groups
   * because when they are encountered with a mismatched key in the slot table, they must be held
   * on to temporarily until the entire parent group finishes execution in case it moved to a
   * later position in the group. Movable groups are only inserted by the compiler as a result of
   * calls to [key].
   *
   * Warning: This is expected to be executed by the compiler only and should not be called
   * directly from source code. Call this API at your own risk.
   *
   * @see [startMovableGroup]
   *
   *
   * 현재 실행 위치에서 “Movable Group”의 끝을 나타냅니다. Movable Group은 형제 그룹 사이에서
   * 이동하거나 순서를 바꾸더라도 슬롯 테이블 상태를 유지할 수 있으며, 제거하거나 삽입할 수도
   * 있는 그룹입니다. 이러한 그룹은 Container Group의 직접 자식으로 삽입될 때만 유효합니다.
   * Movable Group은 다른 그룹보다 비용이 더 큰데, 슬롯 테이블에서 키가 일치하지 않는 경우
   * 나중에 부모 그룹 실행이 끝날 때까지 해당 그룹이 이동했는지를 확인하기 위해 임시로 유지해야
   * 하기 때문입니다. Movable Group은 컴파일러가 [key] 호출의 결과로만 삽입합니다.
   *
   * 경고: 이 함수는 오직 컴파일러에 의해 실행되는 것을 전제로 하며, 소스 코드에서 직접 호출해서는
   * 안 됩니다. 직접 사용할 경우 위험을 감수해야 합니다.
   *
   * @see [startMovableGroup]
   */
  @ComposeCompilerApi
  override fun endMovableGroup() {
    endGroup()
  }

  /**
   * Start the composition. This should be called, and only be called, as the first group in the
   * composition.
   *
   * 구성을 시작합니다. 이는 반드시, 그리고 오직 구성의 첫 번째 그룹에서만 호출되어야 합니다.
   */
  @OptIn(InternalComposeApi::class)
  private fun startRoot() {
    rGroupIndex = 0
    reader = slotTable.openReader()

    startGroup(key = rootKey)

    // parent reference management
    // 부모 참조 관리
    parentContext.startComposing()

    val parentProvider = parentContext.getCompositionLocalScope()

    providersInvalidStack.push(providersInvalid.asInt())
    providersInvalid = changed(value = parentProvider)
    providerCache = null

    // Inform observer if one is defined.
    // 옵저버가 정의되어 있다면 알립니다.
    if (!forceRecomposeScopes) {
      forceRecomposeScopes = parentContext.collectingParameterInformation
    }

    // Propagate collecting source information.
    // 소스 정보 수집을 전파합니다.
    if (!sourceMarkersEnabled) {
      sourceMarkersEnabled = parentContext.collectingSourceInformation
    }

    rootProvider =
      if (sourceMarkersEnabled) {
        @Suppress("UNCHECKED_CAST") // ProvidableCompositionLocal to CompositionLocal
        parentProvider.putValue(
          key = LocalCompositionErrorContext as CompositionLocal<Any?>,
          value = StaticValueHolder(value = errorContext),
        )
      } else {
        parentProvider
      }

    rootProvider.read(key = LocalInspectionTables)?.let { compositionDataSet ->
      compositionDataSet.add(compositionData)
      parentContext.recordInspectionTable(table = compositionDataSet)
    }

    startGroup(key = parentContext.compositeKeyHashCode.hashCode())
  }

  /**
   * End the composition. This should be called, and only be called, to end the first group in the
   * composition.
   *
   * 구성을 종료합니다. 이는 반드시, 그리고 오직 구성의 첫 번째 그룹을 종료할 때만 호출되어야 합니다.
   */
  @OptIn(InternalComposeApi::class)
  private fun endRoot() {
    endGroup()
    parentContext.doneComposing()
    endGroup()
    changeListWriter.endRoot()
    finalizeCompose()
    reader.close()

    forciblyRecompose = false
    providersInvalid = providersInvalidStack.pop().asBool()
  }

  /**
   * Discard a pending composition because an error was encountered during composition.
   *
   * 컴포지션 중 오류가 발생했을 때 대기 중인 컴포지션을 폐기합니다.
   */
  @OptIn(InternalComposeApi::class)
  private fun abortRoot() {
    cleanUpCompose()
    pendingStack.clear()
    parentStateStack.clear()
    entersStack.clear()
    providersInvalidStack.clear()
    providerUpdates = null
    insertFixups.clear()
    compositeKeyHashCode = CompositeKeyHashCode(0)
    childrenComposing = 0
    nodeExpected = false
    inserting = false
    reusing = false
    isComposing = false
    forciblyRecompose = false
    reusingGroup = -1

    if (!reader.closed) {
      reader.close()
    }

    if (!writer.closed) {
      // We cannot just close the insert table as the state of the table is uncertain
      // here and writer.close() might throw.
      //
      // insert 테이블의 상태가 불확실하므로 단순히 닫을 수는 없습니다. 이 시점에서
      // writer.close()를 호출하면 예외가 발생할 수 있습니다.
      forceFreshInsertTable()
    }
  }

  internal fun changesApplied() {
    providerUpdates = null
  }

  /**
   * True if the composition is currently scheduling nodes to be inserted into the tree. During
   * first composition this is always true. During recomposition this is true when new nodes are
   * being scheduled to be added to the tree.
   *
   * 현재 컴포지션이 노드를 트리에 삽입하도록 스케줄링 중이면 true를 반환합니다. 최초 컴포지션
   * 시에는 항상 true이며, 리컴포지션 시에는 새로운 노드가 트리에 추가되도록 스케줄링될 때 true가
   * 됩니다.
   */
  @ComposeCompilerApi
  override var inserting: Boolean = false
    private set

  /** True if the composition should be checking if the composable functions can be skipped. */
  @ComposeCompilerApi
  override val skipping: Boolean
    get() {
      return !inserting &&
        !reusing &&
        !providersInvalid &&
        currentRecomposeScope?.requiresRecompose == false &&
        !forciblyRecompose
    }

  /**
   * Returns the hash of the composite key calculated as a combination of the keys of all the
   * currently started groups via [startGroup].
   *
   * 현재 시작된 모든 그룹의 키를 [startGroup]을 통해 결합하여 계산한 복합 키의 해시를 반환합니다.
   */
  @InternalComposeApi
  override var compositeKeyHashCode: CompositeKeyHashCode = EmptyCompositeKeyHashCode
    private set

  /**
   * Start collecting parameter information and line number information. This enables the tools
   * API to always be able to determine the parameter values of composable calls as well as the
   * source location of calls.
   */
  override fun collectParameterInformation() {
    forceRecomposeScopes = true
    sourceMarkersEnabled = true
    slotTable.collectSourceInformation()
    insertTable.collectSourceInformation()
    writer.updateToTableMaps()
  }

  override fun scheduleFrameEndCallback(action: () -> Unit): CancellationHandle {
    return parentContext.scheduleFrameEndCallback(action)
  }

  @OptIn(InternalComposeApi::class)
  internal fun dispose() {
    trace("Compose:Composer.dispose") {
      parentContext.unregisterComposer(this)
      deactivate()
      applier.clear()
      isDisposed = true
    }
  }

  internal fun deactivate() {
    invalidateStack.clear()
    invalidations.clear()
    changes.clear()
    providerUpdates = null
  }

  internal fun forceRecomposeScopes(): Boolean {
    return if (!forceRecomposeScopes) {
      forceRecomposeScopes = true
      forciblyRecompose = true
      true
    } else {
      false
    }
  }

  /**
   * Start a group with the given key. During recomposition if the currently expected group does
   * not match the given key a group the groups emitted in the same parent group are inspected to
   * determine if one of them has this key and that group the first such group is moved (along
   * with any nodes emitted by the group) to the current position and composition continues. If no
   * group with this key is found, then the composition shifts into insert mode and new nodes are
   * added at the current position.
   *
   * @param key The key for the group
   *
   *
   * 주어진 키로 그룹을 시작합니다. 리컴포지션 중 현재 예상되는 그룹이 주어진 키와 일치하지 않으면,
   * 동일한 부모 그룹에서 생성된 그룹들을 검사하여 해당 키를 가진 그룹이 있는지 확인합니다. 첫 번째로
   * 발견된 그룹은 그 그룹이 생성한 노드들과 함께 현재 위치로 이동되며, 이후 구성이 계속 진행됩니다.
   * 만약 해당 키를 가진 그룹이 발견되지 않으면, 구성이 삽입 모드(insert mode)로 전환되어 현재 위치에
   * 새 노드들이 추가됩니다.
   *
   * @param key 그룹의 키
   */
  private fun startGroup(key: Int) {
    start(
      key = key,
      objectKey = null,
      kind = GroupKind.Group,
      data = null,
    )
  }

  private fun startGroup(key: Int, dataKey: Any?) {
    start(
      key = key,
      objectKey = dataKey,
      kind = GroupKind.Group,
      data = null,
    )
  }

  /**
   * End the current group.
   *
   * 현재 그룹을 종료합니다.
   */
  private fun endGroup() {
    end(isNode = false)
  }

  @OptIn(InternalComposeApi::class)
  private fun skipGroup() {
    groupNodeCount += reader.skipGroup()
  }

  /**
   * Start emitting a node. It is required that [createNode] is called after [startNode]. Similar
   * to [startGroup], if, during recomposition, the current node does not have the provided key a
   * node with that key is scanned for and moved into the current position if found, if no such
   * node is found the composition switches into insert mode and a the node is scheduled to be
   * inserted at the current location.
   *
   * 노드 생성을 시작합니다. [startNode] 이후 반드시 [createNode]가 호출되어야 합니다. [startGroup]과
   * 유사하게, 리컴포지션 중 현재 노드가 제공된 키를 가지고 있지 않다면 해당 키를 가진 노드를 탐색하여
   * 발견 시 현재 위치로 이동시킵니다. 만약 그런 노드가 없다면, 구성이 삽입 모드(insert mode)로 전환되어
   * 현재 위치에 새 노드가 삽입되도록 예약됩니다.
   */
  override fun startNode() {
    start(
      key = nodeKey,
      objectKey = null,
      kind = GroupKind.Node,
      data = null,
    )

    nodeExpected = true
  }

  override fun startReusableNode() {
    start(nodeKey, null, GroupKind.ReusableNode, null)
    nodeExpected = true
  }

  /**
   * Schedule a node to be created and inserted at the current location. This is only valid to
   * call when the composer is inserting.
   */
  @Suppress("UNUSED")
  override fun <T> createNode(factory: () -> T) {
    validateNodeExpected()
    runtimeCheck(inserting) { "createNode() can only be called when inserting" }
    val insertIndex = parentStateStack.peek()
    val groupAnchor = writer.anchor(writer.parent)
    groupNodeCount++
    insertFixups.createAndInsertNode(factory, insertIndex, groupAnchor)
  }

  /** Mark the node that was created by [createNode] as used by composition. */
  @OptIn(InternalComposeApi::class)
  override fun useNode() {
    validateNodeExpected()
    runtimeCheck(!inserting) { "useNode() called while inserting" }
    val node = reader.node
    changeListWriter.moveDown(node)

    if (reusing && node is ComposeNodeLifecycleCallback) {
      changeListWriter.useNode(node)
    }
  }

  /** Called to end the node group. */
  override fun endNode() = end(isNode = true)

  override fun startReusableGroup(key: Int, dataKey: Any?) {
    if (!inserting) {
      if (reader.groupKey == key && reader.groupAux != dataKey && reusingGroup < 0) {
        // Starting to reuse nodes
        reusingGroup = reader.currentGroup
        reusing = true
      }
    }
    start(key, null, GroupKind.Group, dataKey)
  }

  override fun endReusableGroup() {
    if (reusing && reader.parent == reusingGroup) {
      reusingGroup = -1
      reusing = false
    }
    end(isNode = false)
  }

  override fun disableReusing() {
    reusing = false
  }

  override fun enableReusing() {
    reusing = reusingGroup >= 0
  }

  fun startReuseFromRoot() {
    reusingGroup = rootKey
    reusing = true
  }

  fun endReuseFromRoot() {
    requirePrecondition(!isComposing && reusingGroup == rootKey) {
      "Cannot disable reuse from root if it was caused by other groups"
    }
    reusingGroup = -1
    reusing = false
  }

  override val currentMarker: Int
    get() = if (inserting) -writer.parent else reader.parent

  override fun endToMarker(marker: Int) {
    if (marker < 0) {
      // If the marker is negative then the marker is for the writer
      val writerLocation = -marker
      val writer = writer
      while (true) {
        val parent = writer.parent
        if (parent <= writerLocation) break
        end(writer.isNode(parent))
      }
    } else {
      // If the marker is positive then the marker is for the reader. However, if we are
      // inserting then we need to close the inserting groups first.
      if (inserting) {
        // We might be inserting, we need to close all the groups until we are no longer
        // inserting.
        val writer = writer
        while (inserting) {
          end(writer.isNode(writer.parent))
        }
      }
      val reader = reader
      while (true) {
        val parent = reader.parent
        if (parent <= marker) break
        end(reader.isNode(parent))
      }
    }
  }

  /**
   * Schedule a change to be applied to a node's property. This change will be applied to the node
   * that is the current node in the tree which was either created by [createNode].
   */
  override fun <V, T> apply(value: V, block: T.(V) -> Unit) {
    if (inserting) {
      insertFixups.updateNode(value, block)
    } else {
      changeListWriter.updateNode(value, block)
    }
  }

  /**
   * Create a composed key that can be used in calls to [startGroup] or [startNode]. This will use
   * the key stored at the current location in the slot table to avoid allocating a new key.
   *
   * [startGroup]이나 [startNode] 호출에 사용할 수 있는 합성 키를 생성합니다. 이는 슬롯 테이블의
   * 현재 위치에 저장된 키를 활용하여 새 키를 할당하지 않도록 합니다.
   */
  @ComposeCompilerApi
  @OptIn(InternalComposeApi::class)
  override fun joinKey(left: Any?, right: Any?): Any =
    getKey(
      value = reader.groupObjectKey,
      left = left,
      right = right
    )
      ?: JoinedKey(left = left, right = right)

  /**
   * Return the next value in the slot table and advance the current location.
   *
   * 슬롯 테이블에서 다음 값을 반환하고 현재 위치를 앞으로 이동합니다.
   */
  @PublishedApi
  @OptIn(InternalComposeApi::class)
  internal fun nextSlot(): Any? =
    if (inserting) {
      validateNodeNotExpected()
      Composer.Empty
    } else
      reader.next().let { data ->
        if (reusing && data !is ReusableRememberObserverHolder) Composer.Empty else data
      }

  @PublishedApi
  @OptIn(InternalComposeApi::class)
  internal fun nextSlotForCache(): Any? {
    return if (inserting) {
      validateNodeNotExpected()
      Composer.Empty
    } else
      reader.next().let {
        if (reusing && it !is ReusableRememberObserverHolder) Composer.Empty
        else if (it is RememberObserverHolder) it.wrapped else it
      }
  }

  /**
   * Determine if the current slot table value is equal to the given value, if true, the value is
   * scheduled to be skipped during [ControlledComposition.applyChanges] and [changes] return
   * false; otherwise [ControlledComposition.applyChanges] will update the slot table to [value].
   * In either case the composer's slot table is advanced.
   *
   * @param value the value to be compared.
   */
  @ComposeCompilerApi
  override fun changed(value: Any?): Boolean =
    if (nextSlot() != value) {
      updateValue(value)
      true
    } else {
      false
    }

  @ComposeCompilerApi
  override fun changedInstance(value: Any?): Boolean {
    return if (nextSlot() !== value) {
      updateValue(value)
      true
    } else {
      false
    }
  }

  @ComposeCompilerApi
  override fun changed(value: Char): Boolean {
    val next = nextSlot()
    if (next is Char) {
      val nextPrimitive: Char = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Byte): Boolean {
    val next = nextSlot()
    if (next is Byte) {
      val nextPrimitive: Byte = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Short): Boolean {
    val next = nextSlot()
    if (next is Short) {
      val nextPrimitive: Short = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Boolean): Boolean {
    val next = nextSlot()
    if (next is Boolean) {
      val nextPrimitive: Boolean = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Float): Boolean {
    val next = nextSlot()
    if (next is Float) {
      val nextPrimitive: Float = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Long): Boolean {
    val next = nextSlot()
    if (next is Long) {
      val nextPrimitive: Long = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Double): Boolean {
    val next = nextSlot()
    if (next is Double) {
      val nextPrimitive: Double = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  @ComposeCompilerApi
  override fun changed(value: Int): Boolean {
    val next = nextSlot()
    if (next is Int) {
      val nextPrimitive: Int = next
      if (value == nextPrimitive) return false
    }
    updateValue(value)
    return true
  }

  /**
   * Cache a value in the composition. During initial composition [block] is called to produce the
   * value that is then stored in the slot table. During recomposition, if [invalid] is false the
   * value is obtained from the slot table and [block] is not invoked. If [invalid] is false a new
   * value is produced by calling [block] and the slot table is updated to contain the new value.
   */
  @ComposeCompilerApi
  inline fun <T> cache(invalid: Boolean, block: () -> T): T {
    var result = nextSlotForCache()
    if (result === Composer.Empty || invalid) {
      val value = block()
      updateCachedValue(value)
      result = value
    }

    @Suppress("UNCHECKED_CAST")
    return result as T
  }

  private fun updateSlot(value: Any?) {
    nextSlot()
    updateValue(value)
  }

  /**
   * Schedule the current value in the slot table to be updated to [value].
   *
   * @param value the value to schedule to be written to the slot table.
   */
  @PublishedApi
  @OptIn(InternalComposeApi::class)
  internal fun updateValue(value: Any?) {
    if (inserting) {
      writer.update(value = value)
    } else {
      if (reader.hadNext) {
        // We need to update the slot we just read so which is is one previous to the
        // current group slot index.
        //
        // 방금 읽은 슬롯을 업데이트해야 하므로 현재 그룹의 슬롯 인덱스보다 하나 이전
        // 위치를 갱신합니다.
        val groupSlotIndex = reader.groupSlotIndex - 1
        if (changeListWriter.pastParent) {
          // The reader is after the first child of the group so we cannot reposition the
          // writer to the parent to update it as this will cause the writer to navigate
          // backward which violates the single pass, forward walking nature of update.
          // Using an anchored updated allows to to violate this principle just for
          // updating slots as this is required if the update occurs after the writer has
          // been moved past the parent.
          //
          // reader가 그룹의 첫 번째 자식 이후에 있으므로 writer를 부모로 되돌려 업데이트할 수
          // 없습니다. 그렇게 하면 writer가 뒤로 이동하여 업데이트의 [단일 패스 전방 진행 원칙]을
          // 위반합니다. 앵커 기반 업데이트를 사용하면 슬롯만 업데이트하는 경우에 한해 이 원칙을
          // 예외적으로 허용합니다. writer가 부모를 지나 이동한 뒤에 업데이트가 발생하는 상황에서는
          // 이 방식이 필요합니다.
          changeListWriter.updateAnchoredValue(
            value = value,
            anchor = reader.anchor(index = reader.parent),
            groupSlotIndex = groupSlotIndex,
          )
        } else {
          // No children have been seen yet so we are still in a position where we can
          // directly update the parent.
          //
          // 아직 자식이 발견되지 않았으므로 부모를 직접 업데이트할 수 있는 위치에
          // 있습니다.
          changeListWriter.updateValue(value = value, groupSlotIndex = groupSlotIndex)
        }
      } else {
        // This uses an anchor for the same reason as `updateAnchoredValue` uses and anchor,
        // the writer might have advanced past the parent and we need to go back and update
        // the parent. As this is likely to never occur in an empty group, we don't bother
        // checking if the reader has moved so we don't need an anchored and un-anchored
        // version of the same function.
        //
        // 이 경우 updateAnchoredValue가 앵커를 사용하는 것과 같은 이유로 앵커를 사용합니다.
        // writer가 부모를 지나 앞으로 진행했을 수 있으며, 우리는 부모를 다시 업데이트해야 합니다.
        // 빈 그룹에서는 이런 상황이 발생하지 않을 가능성이 크기 때문에 reader가 이동했는지 여부를
        // 확인하지 않으며, 따라서 동일한 함수의 앵커 버전과 비앵커 버전을 따로 둘 필요가 없습니다.
        changeListWriter.appendValue(
          anchor = reader.anchor(index = reader.parent),
          value = value,
        )
      }
    }
  }

  /**
   * Schedule the current value in the slot table to be updated to [value].
   *
   * @param value the value to schedule to be written to the slot table.
   */
  @PublishedApi
  @OptIn(InternalComposeApi::class)
  internal fun updateCachedValue(value: Any?) {
    val toStore =
      if (value is RememberObserver) {
        val holder = RememberObserverHolder(value, rememberObserverAnchor())
        if (inserting) {
          changeListWriter.remember(holder)
        }
        abandonSet.add(value)
        holder
      } else value
    updateValue(toStore)
  }

  private fun rememberObserverAnchor(): Anchor? =
    if (inserting) {
      if (writer.isAfterFirstChild) {
        var group = writer.currentGroup - 1
        var parent = writer.parent(group)
        while (parent != writer.parent && parent >= 0) {
          group = parent
          parent = writer.parent(group)
        }
        writer.anchor(group)
      } else null
    } else {
      if (reader.isAfterFirstChild) {
        var group = reader.currentGroup - 1
        var parent = reader.parent(group)
        while (parent != reader.parent && parent >= 0) {
          group = parent
          parent = reader.parent(group)
        }
        reader.anchor(group)
      } else null
    }

  private var _compositionData: CompositionData? = null

  override val compositionData: CompositionData
    get() {
      val data = _compositionData
      if (data == null) {
        val newData = CompositionDataImpl(composition)
        _compositionData = newData
        return newData
      }
      return data
    }

  /** Schedule a side effect to run when we apply composition changes. */
  override fun recordSideEffect(effect: () -> Unit) {
    changeListWriter.sideEffect(effect)
  }

  private fun currentCompositionLocalScope(): PersistentCompositionLocalMap {
    providerCache?.let {
      return it
    }
    return currentCompositionLocalScope(reader.parent)
  }

  override val currentCompositionLocalMap: CompositionLocalMap
    get() = currentCompositionLocalScope()

  /** Return the current [CompositionLocal] scope which was provided by a parent group. */
  private fun currentCompositionLocalScope(group: Int): PersistentCompositionLocalMap {
    if (inserting && writerHasAProvider) {
      var current = writer.parent
      while (current > 0) {
        if (
          writer.groupKey(current) == compositionLocalMapKey &&
          writer.groupObjectKey(current) == compositionLocalMap
        ) {
          val providers = writer.groupAux(current) as PersistentCompositionLocalMap
          providerCache = providers
          return providers
        }
        current = writer.parent(current)
      }
    }
    if (reader.size > 0) {
      var current = group
      while (current > 0) {
        if (
          reader.groupKey(current) == compositionLocalMapKey &&
          reader.groupObjectKey(current) == compositionLocalMap
        ) {
          val providers =
            providerUpdates?.get(current)
              ?: reader.groupAux(current) as PersistentCompositionLocalMap
          providerCache = providers
          return providers
        }
        current = reader.parent(current)
      }
    }
    providerCache = rootProvider
    return rootProvider
  }

  /**
   * Update (or create) the slots to record the providers. The providers maps are first the scope
   * followed by the map used to augment the parent scope. Both are needed to detect inserts,
   * updates and deletes to the providers.
   */
  private fun updateProviderMapGroup(
    parentScope: PersistentCompositionLocalMap,
    currentProviders: PersistentCompositionLocalMap,
  ): PersistentCompositionLocalMap {
    val providerScope = parentScope.mutate { it.putAll(currentProviders) }
    startGroup(providerMapsKey, providerMaps)
    updateSlot(providerScope)
    updateSlot(currentProviders)
    endGroup()
    return providerScope
  }

  @InternalComposeApi
  @Suppress("UNCHECKED_CAST")
  override fun startProvider(value: ProvidedValue<*>) {
    val parentScope = currentCompositionLocalScope()
    startGroup(providerKey, provider)
    val oldState =
      rememberedValue().let { if (it == Composer.Empty) null else it as ValueHolder<Any?> }
    val local = value.compositionLocal as CompositionLocal<Any?>
    val state = local.updatedStateOf(value as ProvidedValue<Any?>, oldState)
    val change = state != oldState
    if (change) {
      updateRememberedValue(state)
    }
    val providers: PersistentCompositionLocalMap
    val invalid: Boolean
    if (inserting) {
      providers =
        if (value.canOverride || !parentScope.contains(local)) {
          parentScope.putValue(local, state)
        } else {
          parentScope
        }
      invalid = false
      writerHasAProvider = true
    } else {
      val oldScope = reader.groupAux(reader.currentGroup) as PersistentCompositionLocalMap
      providers =
        when {
          (!skipping || change) && (value.canOverride || !parentScope.contains(local)) ->
            parentScope.putValue(local, state)
          !change && !providersInvalid -> oldScope
          providersInvalid -> parentScope
          else -> oldScope
        }
      invalid = reusing || oldScope !== providers
    }
    if (invalid && !inserting) {
      recordProviderUpdate(providers)
    }
    providersInvalidStack.push(providersInvalid.asInt())
    providersInvalid = invalid
    providerCache = providers
    start(compositionLocalMapKey, compositionLocalMap, GroupKind.Group, providers)
  }

  private fun recordProviderUpdate(providers: PersistentCompositionLocalMap) {
    val providerUpdates =
      providerUpdates
        ?: run {
          val newProviderUpdates = MutableIntObjectMap<PersistentCompositionLocalMap>()
          this.providerUpdates = newProviderUpdates
          newProviderUpdates
        }
    providerUpdates[reader.currentGroup] = providers
  }

  @InternalComposeApi
  override fun endProvider() {
    endGroup()
    endGroup()
    providersInvalid = providersInvalidStack.pop().asBool()
    providerCache = null
  }

  @InternalComposeApi
  override fun startProviders(values: Array<out ProvidedValue<*>>) {
    val parentScope = currentCompositionLocalScope()
    startGroup(providerKey, provider)
    val providers: PersistentCompositionLocalMap
    val invalid: Boolean
    if (inserting) {
      val currentProviders = updateCompositionMap(values, parentScope)
      providers = updateProviderMapGroup(parentScope, currentProviders)
      invalid = false
      writerHasAProvider = true
    } else {
      val oldScope = reader.groupGet(0) as PersistentCompositionLocalMap
      val oldValues = reader.groupGet(1) as PersistentCompositionLocalMap
      val currentProviders = updateCompositionMap(values, parentScope, oldValues)
      // skipping is true iff parentScope has not changed.
      if (!skipping || reusing || oldValues != currentProviders) {
        providers = updateProviderMapGroup(parentScope, currentProviders)

        // Compare against the old scope as currentProviders might have modified the scope
        // back to the previous value. This could happen, for example, if currentProviders
        // and parentScope have a key in common and the oldScope had the same value as
        // currentProviders for that key. If the scope has not changed, because these
        // providers obscure a change in the parent as described above, re-enable skipping
        // for the child region.
        invalid = reusing || providers != oldScope
      } else {
        // Nothing has changed
        skipGroup()
        providers = oldScope
        invalid = false
      }
    }

    if (invalid && !inserting) {
      recordProviderUpdate(providers)
    }
    providersInvalidStack.push(providersInvalid.asInt())
    providersInvalid = invalid
    providerCache = providers
    start(compositionLocalMapKey, compositionLocalMap, GroupKind.Group, providers)
  }

  @InternalComposeApi
  override fun endProviders() {
    endGroup()
    endGroup()
    providersInvalid = providersInvalidStack.pop().asBool()
    providerCache = null
  }

  @InternalComposeApi
  override fun <T> consume(key: CompositionLocal<T>): T = currentCompositionLocalScope().read(key)

  /**
   * Create or use a memoized [CompositionContext] instance at this position in the slot table.
   */
  override fun buildContext(): CompositionContext {
    startGroup(referenceKey, reference)
    if (inserting) writer.markGroup()

    var observerHolder = nextSlot() as? RememberObserverHolder
    if (observerHolder == null) {
      observerHolder =
        ReusableRememberObserverHolder(
          CompositionContextHolder(
            CompositionContextImpl(
              this@ComposerImpl.compositeKeyHashCode,
              forceRecomposeScopes,
              sourceMarkersEnabled,
              (composition as? CompositionImpl)?.observerHolder,
            )
          ),
          after = null,
        )
      updateValue(observerHolder)
    }
    val holder = observerHolder.wrapped as CompositionContextHolder
    holder.ref.updateCompositionLocalScope(currentCompositionLocalScope())
    endGroup()

    return holder.ref
  }

  /**
   * The number of changes that have been scheduled to be applied during
   * [ControlledComposition.applyChanges].
   *
   * Slot table movement (skipping groups and nodes) will be coalesced so this number is possibly
   * less than the total changes detected.
   */
  internal val changeCount
    get() = changes.size

  internal val currentRecomposeScope: RecomposeScopeImpl?
    get() =
      invalidateStack.let { stack ->
        if (childrenComposing == 0 && stack.isNotEmpty()) stack.peek() else null
      }

  private fun ensureWriter() {
    if (writer.closed) {
      writer = insertTable.openWriter()

      // Append to the end of the table.
      // 테이블 끝에 추가합니다.
      writer.skipToGroupEnd()

      writerHasAProvider = false
      providerCache = null
    }
  }

  private fun createFreshInsertTable() {
    runtimeCheck(writer.closed)
    forceFreshInsertTable()
  }

  private fun forceFreshInsertTable() {
    insertTable =
      SlotTable().apply {
        if (sourceMarkersEnabled) collectSourceInformation()
        if (parentContext.collectingCallByInformation) collectCalledByInformation()
      }

    writer = insertTable.openWriter().also { it.close(normalClose = true) }
  }

  /**
   * Start the reader group updating the data of the group if necessary.
   *
   * 필요하다면 그룹의 데이터를 갱신하면서 리더 그룹을 시작합니다.
   */
  private fun startReaderGroup(isNode: Boolean, data: Any?) {
    if (isNode) {
      reader.startNode()
    } else {
      if (data != null && reader.groupAux !== data) {
        changeListWriter.updateAuxData(data = data)
      }
      reader.startGroup()
    }
  }

  private fun start(
    key: Int,
    objectKey: Any?,
    kind: GroupKind,
    data: Any?,
  ) {
    validateNodeNotExpected()

    updateCompositeKeyWhenWeEnterGroup(
      groupKey = key,
      rGroupIndex = rGroupIndex,
      dataKey = objectKey,
      data = data,
    )

    if (objectKey == null) rGroupIndex++

    // Check for the insert fast path. If we are already inserting (creating nodes) then
    // there is no need to track insert, deletes and moves with a pending changes object.
    //
    // 삽입 빠른 경로(insert fast path)를 확인합니다. 이미 삽입(노드 생성) 중이라면,
    // 보류 중인 Change 객체로 삽입, 삭제, 이동을 추적할 필요가 없습니다.
    val isNode = kind.isNode

    if (inserting) {
      reader.beginEmpty()

      val startIndex = writer.currentGroup

      when {
        isNode -> {
          writer.startNode(
            key = key,
            objectKey = Composer.Empty
          )
        }
        data != null -> {
          writer.startData(
            key = key,
            objectKey = objectKey ?: Composer.Empty,
            aux = data,
          )
        }
        else -> {
          writer.startGroup(
            key = key,
            dataKey = objectKey ?: Composer.Empty,
          )
        }
      }

      pending?.let { pending ->
        val insertKeyInfo =
          KeyInfo(
            key = key,
            objectKey = -1,
            location = insertedGroupVirtualIndex(index = startIndex),
            nodes = -1,
            index = 0,
          )

        pending.registerInsert(keyInfo = insertKeyInfo, insertIndex = nodeIndex - pending.startIndex)
        pending.recordUsed(keyInfo = insertKeyInfo)
      }

      enterGroup(isNode = isNode, newPending = null)
      return
    }

    // 여기서부터는 inserting == false 일 때만 실행됨

    val forceReplace = !kind.isReusable && reusing

    if (pending == null) {
      val slotKey: Int = reader.groupKey

      if (!forceReplace && slotKey == key && objectKey == reader.groupObjectKey) {
        // The group is the same as what was generated last time.
        // 그룹이 지난번에 생성된 것과 동일합니다.
        startReaderGroup(isNode = isNode, data = data)
      } else {
        pending = Pending(keyInfos = reader.extractKeys(), startIndex = nodeIndex)
      }
    }

    val pending = pending
    var newPending: Pending? = null

    if (pending != null) {
      // Check to see if the key was generated last time from the keys collected above.
      // 위에서 수집한 키들로부터 해당 키가 지난번에 생성된 것인지 확인합니다.
      val keyInfo = pending.getNext(key = key, dataKey = objectKey)

      if (!forceReplace && keyInfo != null) {
        // This group was generated last time, use it.
        // 이 그룹은 지난번에 생성된 것이므로, 그대로 사용합니다.
        pending.recordUsed(keyInfo = keyInfo)

        // Move the slot table to the location where the information about this group is
        // stored. The slot information will move once the changes are applied so moving the
        // current of the slot table is sufficient.
        //
        // 슬롯 테이블을 이 그룹의 정보가 저장된 위치로 이동합니다. 변경 사항이 적용되면
        // 슬롯 정보는 이동하므로, 슬롯 테이블의 현재 위치를 옮기는 것만으로 충분합니다.
        val location = keyInfo.location

        // Determine what index this group is in. This is used for inserting nodes into the
        // group.
        //
        // 이 그룹이 몇 번째 인덱스에 있는지 확인합니다. 이는 노드를 그룹에 삽입할 때 사용됩니다.
        nodeIndex = pending.nodePositionOf(keyInfo = keyInfo) + pending.startIndex

        // Determine how to move the slot group to the correct position.
        // 슬롯 그룹을 올바른 위치로 어떻게 이동할지 결정합니다.
        val relativePosition = pending.slotPositionOf(keyInfo = keyInfo)
        val currentRelativePosition = relativePosition - pending.groupIndex

        pending.registerMoveSlot(from = relativePosition, to = pending.groupIndex)
        changeListWriter.moveReaderRelativeTo(location = location)
        reader.reposition(index = location)

        if (currentRelativePosition > 0) {
          // The slot group must be moved, record the move to be performed during apply.
          // 슬롯 그룹을 이동해야 하므로, apply시 수행할 이동 작업을 기록합니다.
          changeListWriter.moveCurrentGroup(offset = currentRelativePosition)
        }

        startReaderGroup(isNode = isNode, data = data)
      }

      // forceReplace == true || keyInfo == null
      else {
        // The group is new, go into insert mode. All child groups will written to the
        // insertTable until the group is complete which will schedule the groups to be
        // inserted into in the table.
        //
        // 그룹이 새로 생성되었으므로 삽입 모드로 전환합니다. 모든 하위 그룹은 그룹이 완료될
        // 때까지 insertTable에 기록되며, 이후 이 그룹들이 테이블에 삽입되도록 예약됩니다.
        reader.beginEmpty()

        inserting = true
        providerCache = null

        ensureWriter()
        writer.beginInsert()

        val startIndex = writer.currentGroup
        when {
          isNode -> {
            writer.startNode(
              key = key,
              objectKey = Composer.Empty,
            )
          }
          data != null -> {
            writer.startData(
              key = key,
              objectKey = objectKey ?: Composer.Empty,
              aux = data,
            )
          }
          else -> {
            writer.startGroup(
              key = key,
              dataKey = objectKey ?: Composer.Empty,
            )
          }
        }

        insertAnchor = writer.anchor(index = startIndex)

        val insertKeyInfo =
          KeyInfo(
            key = key,
            objectKey = -1,
            location = insertedGroupVirtualIndex(index = startIndex),
            nodes = -1,
            index = 0,
          )

        pending.registerInsert(
          keyInfo = insertKeyInfo,
          insertIndex = nodeIndex - pending.startIndex,
        )
        pending.recordUsed(keyInfo = insertKeyInfo)

        newPending = Pending(
          keyInfos = mutableListOf(),
          startIndex = if (isNode) 0 else nodeIndex,
        )
      }
    }

    enterGroup(isNode = isNode, newPending = newPending)
  }

  private fun enterGroup(isNode: Boolean, newPending: Pending?) {
    // When entering a group all the information about the parent should be saved, to be
    // restored when end() is called, and all the tracking counters set to initial state for the
    // group.
    //
    // 그룹에 진입할 때 부모와 관련된 모든 정보를 저장해 두었다가 end()가 호출되면 복원해야 합니다.
    // 또한 그룹을 위한 모든 추적 카운터들을 초기 상태로 설정해야 합니다.
    pendingStack.push(pending)

    this.pending = newPending
    this.parentStateStack.push(groupNodeCount)
    this.parentStateStack.push(rGroupIndex)
    this.parentStateStack.push(nodeIndex)

    if (isNode) nodeIndex = 0
    groupNodeCount = 0
    rGroupIndex = 0
  }

  private fun exitGroup(expectedNodeCount: Int, inserting: Boolean) {
    // Restore the parent's state updating them if they have changed based on changes in the
    // children. For example, if a group generates nodes then the number of generated nodes will
    // increment the node index and the group's node count. If the parent is tracking structural
    // changes in pending then restore that too.
    //
    // 자식의 변경 사항에 따라 달라진 경우 부모의 상태를 갱신하며 복원합니다. 예를 들어, 그룹이
    // 노드를 생성하면 생성된 노드의 수만큼 노드 인덱스와 그룹의 노드 수가 증가합니다. 또한 부모가
    // 보류 상태에서 구조적 변화를 추적 중이었다면 그것도 함께 복원합니다.
    val previousPending = pendingStack.pop()

    if (previousPending != null && !inserting) {
      previousPending.groupIndex++
    }

    this.pending = previousPending
    this.nodeIndex = parentStateStack.pop() + expectedNodeCount
    this.rGroupIndex = parentStateStack.pop()
    this.groupNodeCount = parentStateStack.pop() + expectedNodeCount
  }

  private fun end(isNode: Boolean) {
    // All the changes to the group (or node) have been recorded. All new nodes have been
    // inserted but it has yet to determine which need to be removed or moved. Note that the
    // changes are relative to the first change in the list of nodes that are changing.
    //
    // 그룹(또는 노드)의 모든 변경 사항이 기록되었습니다. 새로운 노드들은 모두 삽입되었지만,
    // 어떤 노드가 제거되거나 이동해야 하는지는 아직 결정되지 않았습니다. 이때 변경 사항은
    // 변경 중인 노드 목록의 첫 번째 변경을 기준으로 계산됩니다.

    // The rGroupIndex for parent is two pack from the current stack top which has already
    // been incremented past this group needs to be offset by one.
    //
    // 부모의 rGroupIndex는 현재 스택 최상단에서 두 단계 아래에 있으며, 스택은 이미 이 그룹을
    // 지나 증가된 상태이므로 1만큼 보정해야 합니다.
    val rGroupIndex = parentStateStack.peek2() - 1

    if (inserting) {
      val parent = writer.parent
      updateCompositeKeyWhenWeExitGroup(
        groupKey = writer.groupKey(index = parent),
        rGroupIndex = rGroupIndex,
        dataKey = writer.groupObjectKey(index = parent),
        data = writer.groupAux(index = parent),
      )
    } else {
      val parent = reader.parent
      updateCompositeKeyWhenWeExitGroup(
        groupKey = reader.groupKey(index = parent),
        rGroupIndex = rGroupIndex,
        dataKey = reader.groupObjectKey(index = parent),
        data = reader.groupAux(index = parent),
      )
    }

    var expectedNodeCount = groupNodeCount
    val pending = pending

    if (pending != null && pending.keyInfos.isNotEmpty()) {
      // previous contains the list of keys as they were generated in the previous composition.
      // previous는 이전 컴포지션에서 생성된 키들의 목록을 담고 있습니다.
      val previous: MutableList<KeyInfo> = pending.keyInfos

      // current contains the list of keys in the order they need to be in the new composition.
      // current는 새로운 컴포지션에서 필요한 순서대로 정렬된 키들의 목록을 담고 있습니다.
      val current: List<KeyInfo> = pending.used

      // usedKeys contains the keys that were used in the new composition, therefore if a key
      // doesn't exist in this set, it needs to be removed.
      //
      // usedKeys는 새로운 컴포지션에서 사용된 키들을 담고 있습니다. 따라서 이 집합에 존재하지
      // 않는 키는 제거해야 합니다.
      val usedKeys = current.fastToSet()

      val placedKeys = mutableSetOf<KeyInfo>()
      var currentIndex = 0
      val currentEnd = current.size
      var previousIndex = 0
      val previousEnd = previous.size

      // Traverse the list of changes to determine startNode movement.
      // Change 목록을 순회하면서 startNode 이동 여부를 결정합니다.
      var nodeOffset = 0

      while (previousIndex < previousEnd) {
        val previousInfo = previous[previousIndex]
        if (previousInfo !in usedKeys) {
          // If the key info was not used the group was deleted, remove the nodes in the
          // group.
          //
          // 키 정보가 사용되지 않았다면 해당 그룹은 삭제된 것이므로, 그룹 안의 노드들을 제거합니다.
          val deleteOffset = pending.nodePositionOf(keyInfo = previousInfo)

          changeListWriter.removeNode(
            nodeIndex = deleteOffset + pending.startIndex,
            count = previousInfo.nodes,
          )
          pending.updateNodeCount(
            group = previousInfo.location,
            newCount = 0,
          )
          changeListWriter.moveReaderRelativeTo(location = previousInfo.location)
          reader.reposition(index = previousInfo.location)
          recordDelete()
          reader.skipGroup()

          // Remove any invalidations pending for the group being removed. These are no
          // longer part of the composition. The group being composed is one after the
          // start of the group.
          //
          // 제거되는 그룹의 보류 중인 무효화 항목들을 모두 제거합니다. 이들은 더 이상
          // 컴포지션의 일부가 아닙니다. 현재 컴포즈 중인 그룹은 해당 그룹의 시작 이후에
          // 오는 그룹입니다.
          invalidations.removeRange(
            start = previousInfo.location,
            end = previousInfo.location + reader.groupSize(index = previousInfo.location),
          )

          previousIndex++
          continue
        }

        if (previousInfo in placedKeys) {
          // If the group was already placed in the correct location, skip it.
          // 그룹이 이미 올바른 위치에 배치되어 있다면 건너뜁니다.
          previousIndex++
          continue
        }

        if (currentIndex < currentEnd) {
          // At this point current should match previous unless the group is new or was
          // moved.
          //
          // 이 시점에서 current는 새 그룹이거나 이동된 그룹이 아닌 이상 previous와
          // 일치해야 합니다.
          val currentInfo = current[currentIndex]
          if (currentInfo !== previousInfo) {
            val nodePosition = pending.nodePositionOf(keyInfo = currentInfo)
            placedKeys.add(currentInfo)

            if (nodePosition != nodeOffset) {
              val updatedCount = pending.updatedNodeCountOf(keyInfo = currentInfo)

              changeListWriter.moveNode(
                from = nodePosition + pending.startIndex,
                to = nodeOffset + pending.startIndex,
                count = updatedCount,
              )
              pending.registerMoveNode(
                from = nodePosition,
                to = nodeOffset,
                count = updatedCount,
              )
            }
            // else the nodes are already in the correct position.
            // 그렇지 않으면 노드들은 이미 올바른 위치에 있습니다.
          } else {
            // The correct nodes are in the right location.
            // 올바른 노드들이 올바른 위치에 있습니다.
            previousIndex++
          }

          currentIndex++
          nodeOffset += pending.updatedNodeCountOf(keyInfo = currentInfo)
        }
      }

      // If there are any current nodes left they where inserted into the right location
      // when the group began so the rest are ignored.
      //
      // 남아 있는 현재 노드가 있다면, 그룹이 시작될 때 이미 올바른 위치에 삽입되었으므로
      // 나머지는 무시합니다.
      changeListWriter.endNodeMovement()

      // We have now processed the entire list so move the slot table to the end of the list
      // by moving to the last key and skipping it.
      //
      // 이제 전체 목록을 모두 처리했으므로, 마지막 키로 이동한 뒤 이를 건너뛰어 슬롯 테이블을
      // 목록의 끝으로 이동합니다.
      if (previous.isNotEmpty()) {
        changeListWriter.moveReaderRelativeTo(location = reader.groupEnd)
        reader.skipToGroupEnd()
      }
    }

    val inserting = inserting
    if (!inserting) {
      // Detect when slots were not used. This happens when a `remember` was removed at the
      // end of a group. Due to code generation issues (b/346821372) this may also see
      // remembers that were removed prior to the children being called so this must be done
      // before the children are deleted to ensure that the `RememberEventDispatcher` receives
      // the `leaving()` call in the correct order so the `onForgotten` is dispatched in the
      // correct order for the values being removed.
      //
      // 슬롯이 사용되지 않았을 때를 감지합니다. 이는 그룹 끝에서 remember가 제거될 때 발생합니다.
      // 코드 생성 문제(b/346821372) 때문에 자식들이 호출되기 전에 제거된 remember를 감지할 수도
      // 있으므로, 자식들이 삭제되기 전에 이 과정을 수행해야 RememberEventDispatcher가 올바른 순서로
      // leaving() 호출을 받아 제거되는 값들에 대해 onForgotten이 올바른 순서로 디스패치됩니다.
      val remainingSlots = reader.remainingSlots
      if (remainingSlots > 0) {
        changeListWriter.trimValues(count = remainingSlots)
      }
    }

    // Detect removing nodes at the end. No pending is created in this case we just have more
    // nodes in the previous composition than we expect. (i.e. we are not yet at an end)
    //
    // 끝에서 노드가 제거되는 것을 감지합니다. 이 경우에는 Pending이 생성되지 않고, 단지 이전
    // 컴포지션에 예상보다 더 많은 노드가 남아 있는 상황(즉, 아직 끝에 도달하지 않은 상태)입니다.
    val removeIndex = nodeIndex

    while (!reader.isGroupEnd) {
      val startSlot = reader.currentGroup

      recordDelete()

      val nodesToRemove = reader.skipGroup()

      changeListWriter.removeNode(nodeIndex = removeIndex, count = nodesToRemove)
      invalidations.removeRange(start = startSlot, end = reader.currentGroup)
    }

    if (inserting) {
      if (isNode) {
        insertFixups.endNodeInsert()
        expectedNodeCount = 1
      }

      reader.endEmpty()

      val parentGroup = writer.parent

      writer.endGroup()

      if (!reader.inEmpty) {
        val virtualIndex = insertedGroupVirtualIndex(index = parentGroup)

        writer.endInsert()
        writer.close(normalClose = true)

        recordInsert(anchor = insertAnchor)

        this.inserting = false

        if (!slotTable.isEmpty) {
          updateNodeCount(group = virtualIndex, count = 0)
          updateNodeCountOverrides(group = virtualIndex, newCount = expectedNodeCount)
        }
      }
    }

    // inserting == false
    else {
      if (isNode) changeListWriter.moveUp()

      changeListWriter.endCurrentGroup()

      val parentGroup = reader.parent
      val parentNodeCount = updatedNodeCount(group = parentGroup)

      if (expectedNodeCount != parentNodeCount) {
        updateNodeCountOverrides(group = parentGroup, newCount = expectedNodeCount)
      }

      if (isNode) {
        expectedNodeCount = 1
      }

      reader.endGroup()
      changeListWriter.endNodeMovement()
    }

    exitGroup(expectedNodeCount = expectedNodeCount, inserting = inserting)
  }

  /**
   * Recompose any invalidate child groups of the current parent group. This should be called
   * after the group is started but on or before the first child group. It is intended to be
   * called instead of [skipReaderToGroupEnd] if any child groups are invalid. If no children are
   * invalid it will call [skipReaderToGroupEnd].
   *
   * 현재 부모 그룹의 무효화된 자식 그룹들을 다시 컴포즈합니다. 이 메서드는 그룹이 시작된 후,
   * 그러나 첫 번째 자식 그룹이 시작되기 전까지 호출되어야 합니다. 자식 그룹 중 하나라도 무효화된
   * 경우 [skipReaderToGroupEnd] 대신 호출하도록 설계되었습니다. 만약 자식 그룹이 모두 유효하다면
   * [skipReaderToGroupEnd]를 호출합니다.
   */
  private fun recomposeToGroupEnd() {
    val wasComposing = isComposing
    isComposing = true

    var recomposed = false

    val parent = reader.parent
    val end = parent + reader.groupSize(index = parent)
    val recomposeIndex = nodeIndex
    val recomposeCompositeKey = this@ComposerImpl.compositeKeyHashCode
    val oldGroupNodeCount = groupNodeCount
    val oldRGroupIndex = rGroupIndex
    var oldGroup = parent

    var firstInRange = invalidations.firstInRange(start = reader.currentGroup, end = end)

    while (firstInRange != null) {
      val location = firstInRange.location
      val scope = firstInRange.scope

      invalidations.removeLocation(location = location)

      if (firstInRange.isInvalid()) {
        recomposed = true

        reader.reposition(index = location)

        val newGroup = reader.currentGroup

        // Record the changes to the applier location.
        // applier 위치의 변경 사항을 기록합니다.
        recordUpsAndDowns(
          oldGroup = oldGroup,
          newGroup = newGroup,
          commonRoot = parent,
        )
        oldGroup = newGroup

        // Calculate the node index (the distance index in the node this groups nodes are
        // located in the parent node).
        //
        // 노드 인덱스를 계산합니다. 이 값은 이 그룹의 노드들이 부모 노드에서 위치한
        // 노드까지의 거리 인덱스입니다.
        nodeIndex = nodeIndexOf(
          groupLocation = location,
          group = newGroup,
          recomposeGroup = parent,
          recomposeIndex = recomposeIndex,
        )

        // Calculate the current rGroupIndex for this node, storing any parent rGroup
        // indexes we needed into the rGroup IntList.
        //
        // 이 노드의 현재 rGroupIndex를 계산하고, 필요한 부모 rGroup 인덱스들을
        // rGroup IntList에 저장합니다.
        rGroupIndex = rGroupIndexOf(group = newGroup)

        // Calculate the composite hash code (a semi-unique code for every group in the
        // composition used to restore saved state).
        //
        // 합성 해시 코드를 계산합니다. (저장된 상태를 복원하는 데 사용되는, 컴포지션 내
        // 각 그룹을 구분하기 위한 반고유 코드)
        val newParent = reader.parent(index = newGroup)

        this@ComposerImpl.compositeKeyHashCode =
          compositeKeyOf(
            group = newParent,
            recomposeGroup = parent,
            recomposeKey = recomposeCompositeKey,
          )

        // We have moved so the cached lookup of the provider is invalid.
        // 이동했으므로 캐시된 provider 조회는 더 이상 유효하지 않습니다.
        providerCache = null

        // Invoke the function with the same parameters as the last composition (which
        // were captured in the lambda set into the scope).
        //
        // 마지막 컴포지션에서와 동일한 매개변수로 함수를 호출합니다. 이 매개변수들은
        // 스코프에 설정된 람다에 캡처되어 있습니다.
        scope.compose(composer = this)

        // We could have moved out of a provider so the provider cache is invalid.
        // provider 밖으로 이동했을 수 있으므로 provider 캐시는 유효하지 않습니다.
        providerCache = null

        // Restore the parent of the reader to the previous parent.
        // 리더의 부모를 이전 부모로 복원합니다.
        reader.restoreParent(index = parent)
      }

      // firstInRange.isInvalid() == false
      else {
        // If the invalidation is not used restore the reads that were removed when the
        // the invalidation was recorded. This happens, for example, when on of a derived
        // state's dependencies changed but the derived state itself was not changed.
        //
        // 무효화가 사용되지 않았다면, 무효화가 기록될 때 제거된 읽기들을 복원합니다.
        // 예를 들어, 파생 상태의 의존성이 변경되었지만 파생 상태 자체는 변경되지 않은 경우
        // 이런 일이 발생합니다.
        invalidateStack.push(scope)

        val observer = observerHolder.current()
        if (observer != null) {
          try {
            observer.onScopeEnter(scope = scope)
            scope.rereadTrackedInstances()
          } finally {
            observer.onScopeExit(scope = scope)
          }
        } else {
          scope.rereadTrackedInstances()
        }

        invalidateStack.pop()
      }

      // Using `slots.current` here ensures composition always walks forward even if a component
      // before the current composition is invalidated when performing this composition. Any
      // such components will be considered invalid for the next composition. Skipping them
      // prevents potential infinite recomposes at the cost of potentially missing a compose
      // as well as simplifies the apply as it always modifies the slot table in a forward
      // direction.
      //
      // 여기서 `slots.current`를 사용하면, 현재 컴포지션을 수행할 때 이전 컴포넌트가 무효화되더라도
      // 컴포지션이 항상 앞으로 진행되도록 보장합니다. 이러한 컴포넌트들은 다음 컴포지션에서
      // 무효한 것으로 간주됩니다. 이를 건너뛰면 잠재적으로 한 번의 컴포즈를 놓칠 수 있지만,
      // 무한 리컴포즈를 방지하고 적용 과정이 단순해집니다. 왜냐하면 슬롯 테이블이 항상 앞으로만
      // 수정되기 때문입니다.
      firstInRange = invalidations.firstInRange(start = reader.currentGroup, end = end)
    }

    if (recomposed) {
      recordUpsAndDowns(
        oldGroup = oldGroup,
        newGroup = parent,
        commonRoot = parent,
      )

      reader.skipToGroupEnd()

      val parentGroupNodes = updatedNodeCount(group = parent)

      nodeIndex = recomposeIndex + parentGroupNodes
      groupNodeCount = oldGroupNodeCount + parentGroupNodes
      rGroupIndex = oldRGroupIndex
    }

    // recomposed == false
    // MEMO 리컴포지션 스킵 처리?
    else {
      // No recompositions were requested in the range, skip it.
      // 해당 범위에서 리컴포지션이 요청되지 않았으므로 건너뜁니다.
      skipReaderToGroupEnd()

      // No need to restore the parent state for nodeIndex, groupNodeCount and
      // rGroupIndex as they are going to be restored immediately by the endGroup.
      //
      // nodeIndex, groupNodeCount, rGroupIndex의 부모 상태는 복원할 필요가 없습니다.
      // endGroup에서 곧바로 복원되기 때문입니다.
    }

    this@ComposerImpl.compositeKeyHashCode = recomposeCompositeKey
    isComposing = wasComposing
  }

  /**
   * The index in the insertTable overlap with indexes the slotTable so the group index used to
   * track newly inserted groups is set to be negative offset from -2. This reserves -1 as the
   * root index which is the parent value returned by the root groups of the slot table.
   *
   * This function will also restore a virtual index to its index in the insertTable which is not
   * needed here but could be useful for debugging.
   *
   *
   * insertTable의 인덱스는 slotTable의 인덱스와 겹치므로, 새로 삽입된 그룹을 추적하기 위해 사용하는
   * 그룹 인덱스는 -2부터 시작하는 음수 오프셋으로 설정됩니다. 여기서 -1은 루트 인덱스로 예약되며,
   * 이는 slot table의 루트 그룹들이 반환하는 부모 값입니다.
   *
   * 또한 이 함수는 가상 인덱스를 insertTable의 실제 인덱스로 복원하기도 합니다. 이 기능은 여기서는
   * 필요하지 않지만 디버깅에는 유용할 수 있습니다.
   */
  private fun insertedGroupVirtualIndex(index: Int): Int = (-2) - index

  /**
   * As operations to insert and remove nodes are recorded, the number of nodes that will be in
   * the group after changes are applied is maintained in a side overrides table. This method
   * updates that count and then updates any parent groups that include the nodes this group
   * emits.
   *
   * 노드 삽입과 제거 작업이 기록될 때, 변경 사항이 적용된 후 그룹에 포함될 노드 수는 별도의
   * 오버라이드 테이블에 유지됩니다. 이 메서드는 그 수를 갱신한 뒤, 해당 그룹이 내보내는 노드를
   * 포함하는 부모 그룹들도 함께 갱신합니다.
   */
  private fun updateNodeCountOverrides(group: Int, newCount: Int) {
    // The value of group can be negative which indicates it is tracking an inserted group
    // instead of an existing group. The index is a virtual index calculated by
    // insertedGroupVirtualIndex which corresponds to the location of the groups to insert in
    // the insertTable.
    //
    // group 값이 음수일 수 있는데, 이는 기존 그룹이 아니라 새로 삽입된 그룹을 추적하고 있음을
    // 의미합니다. index는 insertedGroupVirtualIndex로 계산된 가상 인덱스로, insertTable에 삽입될
    // 그룹의 위치에 해당합니다.
    val currentCount = updatedNodeCount(group = group)
    if (currentCount != newCount) {
      // Update the overrides.
      // 오버라이드를 갱신합니다.
      val delta = newCount - currentCount
      var current = group
      var minPending = pendingStack.size - 1

      while (current != -1) {
        val newCurrentNodes = updatedNodeCount(group = current) + delta

        updateNodeCount(group = current, count = newCurrentNodes)

        for (pendingIndex in minPending downTo 0) {
          val pending = pendingStack.peek(index = pendingIndex)
          if (
            pending != null &&
            pending.updateNodeCount(group = current, newCount = newCurrentNodes)
          ) {
            minPending = pendingIndex - 1
            break
          }
        }

        if (current < 0) {
          current = reader.parent
        } else {
          if (reader.isNode(index = current)) break
          current = reader.parent(index = current)
        }
      }
    }
  }

  /**
   * Calculates the node index (the index in the child list of a node will appear in the resulting
   * tree) for [group]. Passing in [recomposeGroup] and its node index in [recomposeIndex] allows
   * the calculation to exit early if there is no node group between [group] and [recomposeGroup].
   *
   * [group]의 노드 인덱스를 계산합니다. 이 인덱스는 결과 트리에서 노드의 자식 목록에 나타나는
   * 위치를 의미합니다. [recomposeGroup]과 그 노드 인덱스를 [recomposeIndex]로 전달하면, [group]과
   * [recomposeGroup] 사이에 노드 그룹이 없을 경우 계산을 일찍 종료할 수 있습니다.
   */
  private fun nodeIndexOf(
    groupLocation: Int,
    group: Int,
    recomposeGroup: Int,
    recomposeIndex: Int,
  ): Int {
    // Find the anchor group which is either the recomposeGroup or the first parent node.
    // 앵커 그룹을 찾습니다. 이는 recomposeGroup이거나 첫 번째 부모 노드입니다.
    var anchorGroup = reader.parent(index = group)

    while (anchorGroup != recomposeGroup) {
      if (reader.isNode(index = anchorGroup))
        break

      anchorGroup = reader.parent(index = anchorGroup)
    }

    var index = if (reader.isNode(index = anchorGroup)) 0 else recomposeIndex

    // An early out if the group and anchor are the same.
    // 그룹과 앵커가 같으면 일찍 종료합니다.
    if (anchorGroup == group) return index

    // Walk down from the anchor group counting nodes of siblings in front of this group.
    // 앵커 그룹에서 내려가며 이 그룹 앞에 있는 형제 노드들을 세어 나갑니다.
    var current = anchorGroup
    val nodeIndexLimit =
      index + (updatedNodeCount(group = anchorGroup) - reader.nodeCount(index = group))

    loop@ while (index < nodeIndexLimit) {
      if (current == groupLocation)
        break

      current++

      while (current < groupLocation) {
        val end = current + reader.groupSize(index = current)

        if (groupLocation < end) continue@loop

        index +=
          if (reader.isNode(index = current))
            1
          else
            updatedNodeCount(group = current)

        current = end
      }

      break
    }

    return index
  }

  private fun rGroupIndexOf(group: Int): Int {
    var result = 0
    val parent = reader.parent(index = group)
    var child = parent + 1

    while (child < group) {
      if (!reader.hasObjectKey(index = child))
        result++

      child += reader.groupSize(index = child)
    }

    return result
  }

  private fun updatedNodeCount(group: Int): Int {
    if (group < 0)
      return nodeCountVirtualOverrides?.getOrDefault(group, 0) ?: 0

    val nodeCounts = nodeCountOverrides
    if (nodeCounts != null) {
      val override = nodeCounts[group]
      if (override >= 0) return override
    }

    return reader.nodeCount(index = group)
  }

  private fun updateNodeCount(group: Int, count: Int) {
    if (updatedNodeCount(group = group) != count) {
      if (group < 0) {
        val virtualCounts = nodeCountVirtualOverrides ?: run {
          val newCounts = MutableIntIntMap()
          nodeCountVirtualOverrides = newCounts
          newCounts
        }
        virtualCounts[group] = count
      } else {
        val nodeCounts = nodeCountOverrides ?: run {
          val newCounts = IntArray(reader.size)
          newCounts.fill(-1)
          nodeCountOverrides = newCounts
          newCounts
        }
        nodeCounts[group] = count
      }
    }
  }

  private fun clearUpdatedNodeCounts() {
    nodeCountOverrides = null
    nodeCountVirtualOverrides = null
  }

  /**
   * Records the operations necessary to move the applier the node affected by the previous group
   * to the new group.
   *
   * 이전 그룹의 영향을 받은 노드를 새로운 그룹으로 옮기기 위해 applier에 필요한 작업을 기록합니다.
   */
  private fun recordUpsAndDowns(oldGroup: Int, newGroup: Int, commonRoot: Int) {
    val reader = reader
    val nearestCommonRoot =
      reader.nearestCommonRootOf(
        aGroup = oldGroup,
        bGroup = newGroup,
        common = commonRoot,
      )

    // Record ups for the nodes between oldGroup and nearestCommonRoot.
    // oldGroup과 nearestCommonRoot 사이 노드들의 상향 이동을 기록합니다.
    var current = oldGroup

    while (current > 0 && current != nearestCommonRoot) {
      if (reader.isNode(index = current))
        changeListWriter.moveUp()

      current = reader.parent(index = current)
    }

    // Record downs from nearestCommonRoot to newGroup.
    // nearestCommonRoot에서 newGroup으로의 하향 이동을 기록합니다.
    doRecordDownsFor(group = newGroup, nearestCommonRoot = nearestCommonRoot)
  }

  private fun doRecordDownsFor(group: Int, nearestCommonRoot: Int) {
    if (group > 0 && group != nearestCommonRoot) {
      doRecordDownsFor(
        group = reader.parent(index = group),
        nearestCommonRoot = nearestCommonRoot
      )

      if (reader.isNode(index = group))
        changeListWriter.moveDown(node = reader.nodeAt(index = group))
    }
  }

  /**
   * Calculate the composite key (a semi-unique key produced for every group in the composition)
   * for [group]. Passing in the [recomposeGroup] and [recomposeKey] allows this method to exit
   * early.
   *
   * 컴포지션의 각 그룹에 생성되는 반고유 키인 합성 키를 [group]을 기준으로 계산합니다.
   * [recomposeGroup]과 [recomposeKey]를 전달하면 이 메서드는 일찍 종료할 수 있습니다.
   */
  private fun compositeKeyOf(
    group: Int,
    recomposeGroup: Int,
    recomposeKey: CompositeKeyHashCode,
  ): CompositeKeyHashCode {
    // The general form of a group's compositeKey can be solved by recursively evaluating:
    //
    //    compositeKey(group) = ((compositeKey(parent(group)) rol 3)
    //                            xor compositeKeyPart(group) rol 3)
    //                            xor effectiveRGroupIndex
    //
    // To solve this without recursion, first expand the terms:
    //
    //    compositeKey(group) = (compositeKey(parent(group)) rol 6)
    //                            xor (compositeKeyPart(group) rol 3)
    //                            xor effectiveRGroupIndex
    //
    // Then rewrite this as an iterative XOR sum, where n represents the distance from the
    // starting node and takes the range `0 <= n < depth(group)` and `g - n` represents the n-th
    // parent of g, and all terms are XOR-ed together:
    //
    //    [compositeKeyPart(g - n) rol (6n + 3)] xor [rGroupIndexOf(g - n) rol (6n)]
    //
    // Because `compositeKey(g - n)` is known when `(g - n) == recomposeGroup`, we can terminate
    // early and substitute that iteration's terms with `recomposeKey rol (6n)`.
    //
    //
    //
    // 그룹의 compositeKey 일반식은 다음과 같이 재귀적으로 계산할 수 있습니다:
    //
    //    compositeKey(group) = ((compositeKey(parent(group)) rol 3)
    //                            xor compositeKeyPart(group) rol 3)
    //                            xor effectiveRGroupIndex
    //
    // 이를 재귀 없이 풀기 위해 항들을 전개하면 다음과 같습니다:
    //
    //    compositeKey(group) = (compositeKey(parent(group)) rol 6)
    //                            xor (compositeKeyPart(group) rol 3)
    //                            xor effectiveRGroupIndex
    //
    // 이제 이를 반복적인 XOR 합으로 다시 쓸 수 있습니다. 여기서 n은 시작 노드로부터의 거리를
    // 나타내며 범위는 `0 <= n < depth(group)`이고, `g - n`은 g의 n번째 부모를 의미합니다.
    // 모든 항들은 XOR 연산으로 결합됩니다:
    //
    //    [compositeKeyPart(g - n) rol (6n + 3)] xor [rGroupIndexOf(g - n) rol (6n)]
    //
    // `(g - n) == recomposeGroup`일 때 `compositeKey(g - n)`을 알고 있으므로, 이 경우에는 조기
    // 종료하고 해당 반복 항을 `recomposeKey rol (6n)`으로 대체할 수 있습니다.

    var keyRot = 3
    var rgiRot = 0
    var result = CompositeKeyHashCode(initial = 0)

    var parent = group
    while (parent >= 0) {
      if (parent == recomposeGroup) {
        result = result.bottomUpCompoundWith(segment = recomposeKey, shift = rgiRot)
        return result
      }

      val groupKey = reader.groupCompositeKeyPart(group = parent)

      if (groupKey == movableContentKey) {
        result = result.bottomUpCompoundWith(segment = groupKey, shift = rgiRot)
        return result
      }

      val effectiveRGroupIndex =
        if (reader.hasObjectKey(index = parent))
          0
        else
          rGroupIndexOf(group = parent)

      result =
        result
          .bottomUpCompoundWith(segment = groupKey, shift = keyRot)
          .bottomUpCompoundWith(segment = effectiveRGroupIndex, shift = rgiRot)

      keyRot = (keyRot + 6) % CompositeKeyHashSizeBits
      rgiRot = (rgiRot + 6) % CompositeKeyHashSizeBits

      parent = reader.parent(index = parent)
    }

    return result
  }

  private fun SlotReader.groupCompositeKeyPart(group: Int): Int =
    if (hasObjectKey(index = group)) {
      groupObjectKey(index = group)
        ?.let { objectKey ->
          when (objectKey) {
            is Enum<*> -> objectKey.ordinal
            is MovableContent<*> -> movableContentKey
            else -> objectKey.hashCode()
          }
        }
        ?: 0
    } else {
      groupKey(index = group).let { groupKey ->
        if (groupKey == reuseKey) {
          groupAux(index = group)
            ?.let { aux -> if (aux == Composer.Empty) groupKey else aux.hashCode() }
            ?: groupKey
        } else {
          groupKey
        }
      }
    }

  internal fun tryImminentInvalidation(scope: RecomposeScopeImpl, instance: Any?): Boolean {
    val anchor = scope.anchor ?: return false
    val slotTable = reader.table
    val location = anchor.toIndexFor(slotTable)
    if (isComposing && location >= reader.currentGroup) {
      // if we are invalidating a scope that is going to be traversed during this
      // composition.
      invalidations.insertIfMissing(location, scope, instance)
      return true
    }
    return false
  }

  @TestOnly
  internal fun parentKey(): Int {
    return if (inserting) {
      writer.groupKey(writer.parent)
    } else {
      reader.groupKey(reader.parent)
    }
  }

  /**
   * Skip a group. Skips the group at the current location. This is only valid to call if the
   * composition is not inserting.
   */
  @ComposeCompilerApi
  override fun skipCurrentGroup() {
    if (invalidations.isEmpty()) {
      skipGroup()
    } else {
      val reader = reader
      val key = reader.groupKey
      val dataKey = reader.groupObjectKey
      val aux = reader.groupAux
      val rGroupIndex = rGroupIndex
      updateCompositeKeyWhenWeEnterGroup(key, rGroupIndex, dataKey, aux)
      startReaderGroup(reader.isNode, null)
      recomposeToGroupEnd()
      reader.endGroup()
      updateCompositeKeyWhenWeExitGroup(key, rGroupIndex, dataKey, aux)
    }
  }

  private fun skipReaderToGroupEnd() {
    groupNodeCount = reader.parentNodes
    reader.skipToGroupEnd()
  }

  @ComposeCompilerApi
  override fun shouldExecute(parametersChanged: Boolean, flags: Int): Boolean {
    // We only want to pause when we are not resuming and only when inserting new content or
    // when reusing content. This 0 bit of `flags` is only 1 if this function was restarted by
    // the restart lambda. The other bits of this flags are currently all 0's and are reserved
    // for future use.
    if (((flags and 0b1) == 0) && (inserting || reusing)) {
      val callback = shouldPauseCallback ?: return true
      val scope = currentRecomposeScope ?: return true
      val pausing = callback.shouldPause()
      if (pausing && !scope.resuming) {
        scope.used = true
        // Force the composer back into the reusing state when this scope restarts.
        scope.reusing = reusing
        scope.paused = true
        // Remember a place-holder object to ensure all remembers are sent in the correct
        // order. The remember manager will record the remember callback for the resumed
        // content into a place-holder to ensure that, when the remember callbacks are
        // dispatched, the callbacks for the resumed content are dispatched in the same
        // order they would have been had the content not paused.
        changeListWriter.rememberPausingScope(scope)
        parentContext.reportPausedScope(scope)
        return false
      }
      return true
    }

    // Otherwise we should execute the function if the parameters have changed or when
    // skipping is disabled.
    return parametersChanged || !skipping
  }

  /** Skip to the end of the group opened by [startGroup]. */
  @ComposeCompilerApi
  override fun skipToGroupEnd() {
    runtimeCheck(groupNodeCount == 0) {
      "No nodes can be emitted before calling skipAndEndGroup"
    }

    // This can be called when inserting is true and `shouldExecute` returns false.
    // When `inserting` the writer is already at the end of the group so we don't need to
    // move the writer.
    if (!inserting) {
      currentRecomposeScope?.scopeSkipped()
      if (invalidations.isEmpty()) {
        skipReaderToGroupEnd()
      } else {
        recomposeToGroupEnd()
      }
    }
  }

  @ComposeCompilerApi
  override fun deactivateToEndGroup(changed: Boolean) {
    runtimeCheck(groupNodeCount == 0) {
      "No nodes can be emitted before calling deactivateToEndGroup"
    }
    if (!inserting) {
      if (!changed) {
        skipReaderToGroupEnd()
        return
      }
      val start = reader.currentGroup
      val end = reader.currentEnd
      changeListWriter.deactivateCurrentGroup()
      invalidations.removeRange(start, end)
      reader.skipToGroupEnd()
    }
  }

  /**
   * Start a restart group. A restart group creates a recompose scope and sets it as the current
   * recompose scope of the composition. If the recompose scope is invalidated then this group
   * will be recomposed. A recompose scope can be invalidated by calling invalidate on the object
   * returned by [androidx.compose.runtime.currentRecomposeScope].
   *
   * restart group을 시작합니다. restart group은 recomposeScope를 생성하고 이를 구성의 현재
   * recomposeScope로 설정합니다. recomposeScope가 무효화되면 이 그룹은 다시 컴포즈됩니다.
   * recomposeScope는 [androidx.compose.runtime.currentRecomposeScope]가 반환하는 객체의
   * invalidate를 호출하여 무효화할 수 있습니다.
   */
  @ComposeCompilerApi
  override fun startRestartGroup(key: Int): Composer {
    startReplaceGroup(key = key)
    addRecomposeScope()
    return this
  }

  private fun addRecomposeScope() {
    if (inserting) {
      val scope = RecomposeScopeImpl(owner = composition)

      invalidateStack.push(scope)
      updateValue(value = scope)
      enterRecomposeScope(scope = scope)
    } else {
      val invalidation = invalidations.removeLocation(location = reader.parent)
      val slot = reader.next()
      val scope =
        if (slot == Composer.Empty) {
          // This code is executed when a previously deactivate region is becomes active
          // again. See Composer.deactivateToEndGroup().
          //
          // 이 코드는 이전에 비활성화된 영역이 다시 활성화될 때 실행됩니다.
          // Composer.deactivateToEndGroup()을 참고하세요.
          val newScope = RecomposeScopeImpl(owner = composition)
          updateValue(value = newScope)
          newScope
        } else {
          slot as RecomposeScopeImpl
        }

      scope.requiresRecompose =
        invalidation != null ||
          scope.forcedRecompose.also { forced ->
            if (forced) scope.forcedRecompose = false
          }

      invalidateStack.push(scope)
      enterRecomposeScope(scope = scope)

      if (scope.paused) {
        scope.paused = false
        scope.resuming = true

        changeListWriter.startResumingScope(scope = scope)

        if (!reusing && scope.reusing) {
          reusing = true
          scope.resetReusing = true
        }
      }
    }
  }

  private fun enterRecomposeScope(scope: RecomposeScopeImpl) {
    scope.start(token = compositionToken)
    observerHolder.current()?.onScopeEnter(scope = scope)
  }

  /**
   * End a restart group. If the recompose scope was marked used during composition then a
   * [ScopeUpdateScope] is returned that allows attaching a lambda that will produce the same
   * composition as was produced by this group (including calling [startRestartGroup] and
   * [endRestartGroup]).
   *
   * restart group을 종료합니다. 컴포지션 중 recomposeScope가 사용되었다면, [ScopeUpdateScope]가
   * 반환되어 람다를 연결할 수 있으며, 이 람다는 이 그룹에서 생성된 것과 동일한 컴포지션을 다시
   * 생성합니다 ([startRestartGroup]과 [endRestartGroup] 호출 포함).
   */
  @ComposeCompilerApi
  override fun endRestartGroup(): ScopeUpdateScope? {
    // This allows for the invalidate stack to be out of sync since this might be called during
    // exception stack unwinding that might have not called the doneJoin/endRestartGroup in the
    // the correct order.
    //
    // 예외 스택이 풀리는 과정에서 doneJoin/endRestartGroup이 올바른 순서로 호출되지 않았을 수
    // 있으므로, 무효화 스택이 동기화되지 않아도 되도록 허용합니다.
    val scope =
      if (invalidateStack.isNotEmpty())
        invalidateStack.pop()
      else
        null

    if (scope != null) {
      scope.requiresRecompose = false

      exitRecomposeScope(scope)?.let {
        changeListWriter.endCompositionScope(action = it, composition = composition)
      }

      if (scope.resuming) {
        scope.resuming = false
        changeListWriter.endResumingScope(scope = scope)
        scope.reusing = false

        if (scope.resetReusing) {
          scope.resetReusing = false
          reusing = false
        }
      }
    }

    val result =
      if (
        scope != null &&
        !scope.skipped &&
        (scope.used || forceRecomposeScopes)
      ) {
        if (scope.anchor == null) {
          scope.anchor =
            if (inserting)
              writer.anchor(index = writer.parent)
            else
              reader.anchor(index = reader.parent)
        }

        scope.defaultsInvalid = false
        scope
      } else {
        null
      }

    end(isNode = false)
    return result
  }

  private fun exitRecomposeScope(scope: RecomposeScopeImpl): ((Composition) -> Unit)? {
    observerHolder.current()?.onScopeExit(scope = scope)
    return scope.end(token = compositionToken)
  }

  @InternalComposeApi
  override fun insertMovableContent(value: MovableContent<*>, parameter: Any?) {
    @Suppress("UNCHECKED_CAST")
    invokeMovableContentLambda(
      content = value as MovableContent<Any?>,
      locals = currentCompositionLocalScope(),
      parameter = parameter,
      force = false,
    )
  }

  @OptIn(ExperimentalComposeApi::class)
  private fun invokeMovableContentLambda(
    content: MovableContent<Any?>,
    locals: PersistentCompositionLocalMap,
    parameter: Any?,
    force: Boolean,
  ) {
    // Start the movable content group
    startMovableGroup(movableContentKey, content)
    updateSlot(parameter)

    // All movable content has a composite hash value rooted at the content itself so the hash
    // value doesn't change as the content moves in the tree.
    val savedCompositeKeyHash = compositeKeyHashCode

    try {
      compositeKeyHashCode = CompositeKeyHashCode(movableContentKey)

      if (inserting) writer.markGroup()

      // Capture the local providers at the point of the invocation. This allows detecting
      // changes to the locals as the value moves well as enables finding the correct
      // providers
      // when applying late changes which might be very complicated otherwise.
      val providersChanged = if (inserting) false else reader.groupAux != locals
      if (providersChanged) recordProviderUpdate(locals)
      start(compositionLocalMapKey, compositionLocalMap, GroupKind.Group, locals)
      providerCache = null

      // Either insert a place-holder to be inserted later (either created new or moved from
      // another location) or (re)compose the movable content. This is forced if a new value
      // needs to be created as a late change.
      if (
        inserting &&
        !force &&
        (!ComposeRuntimeFlags.isMovableContentUsageTrackingEnabled || content.used)
      ) {
        writerHasAProvider = true

        // Create an anchor to the movable group
        val anchor = writer.anchor(writer.parent(writer.parent))
        val reference =
          MovableContentStateReference(
            content,
            parameter,
            composition,
            insertTable,
            anchor,
            emptyList(),
            currentCompositionLocalScope(),
            null,
          )
        parentContext.insertMovableContent(reference)
      } else {
        val savedProvidersInvalid = providersInvalid
        providersInvalid = providersChanged
        content.used = true
        invokeComposable(this, { content.content(parameter) })
        providersInvalid = savedProvidersInvalid
      }
    } catch (e: Throwable) {
      throw e.attachComposeStackTrace { currentStackTrace() }
    } finally {
      // Restore the state back to what is expected by the caller.
      endGroup()
      providerCache = null
      compositeKeyHashCode = savedCompositeKeyHash
      endMovableGroup()
    }
  }

  @InternalComposeApi
  override fun insertMovableContentReferences(
    references: List<Pair<MovableContentStateReference, MovableContentStateReference?>>,
  ) {
    var completed = false
    try {
      insertMovableContentGuarded(references)
      completed = true
    } finally {
      if (completed) {
        cleanUpCompose()
      } else {
        // if we finished with error, cleanup more aggressively
        abortRoot()
      }
    }
  }

  private fun insertMovableContentGuarded(
    references: List<Pair<MovableContentStateReference, MovableContentStateReference?>>,
  ) {
    changeListWriter.withChangeList(lateChanges) {
      changeListWriter.resetSlots()
      references.fastForEach { (to, from) ->
        val anchor = to.anchor
        val location = to.slotTable.anchorIndex(anchor)
        val effectiveNodeIndex = IntRef()
        // Insert content at the anchor point
        changeListWriter.determineMovableContentNodeIndex(effectiveNodeIndex, anchor)
        if (from == null) {
          val toSlotTable = to.slotTable
          if (toSlotTable == insertTable) {
            // We are going to compose reading the insert table which will also
            // perform an insert. This would then cause both a reader and a writer to
            // be created simultaneously which will throw an exception. To prevent
            // that we release the old insert table and replace it with a fresh one.
            // This allows us to read from the old table and write to the new table.

            // This occurs when the placeholder version of movable content was inserted
            // but no content was available to move so we now need to create the
            // content.

            createFreshInsertTable()
          }
          to.slotTable.read { reader ->
            reader.reposition(location)
            changeListWriter.moveReaderToAbsolute(location)
            val offsetChanges = ChangeList()
            recomposeMovableContent {
              changeListWriter.withChangeList(offsetChanges) {
                withReader(reader) {
                  changeListWriter.withoutImplicitRootStart {
                    invokeMovableContentLambda(
                      to.content,
                      to.locals,
                      to.parameter,
                      force = true,
                    )
                  }
                }
              }
            }
            changeListWriter.includeOperationsIn(
              other = offsetChanges,
              effectiveNodeIndex = effectiveNodeIndex,
            )
          }
        } else {
          // If the state was already removed from the from table then it will have a
          // state recorded in the recomposer, retrieve that now if we can. If not the
          // state is still in its original location, recompose over it there.
          val resolvedState = parentContext.movableContentStateResolve(from)
          val fromTable = resolvedState?.slotTable ?: from.slotTable
          val fromAnchor = resolvedState?.slotTable?.anchor(0) ?: from.anchor
          val nodesToInsert = fromTable.collectNodesFrom(fromAnchor)

          // Insert nodes if necessary
          if (nodesToInsert.isNotEmpty()) {
            changeListWriter.copyNodesToNewAnchorLocation(
              nodesToInsert,
              effectiveNodeIndex,
            )
            if (to.slotTable == slotTable) {
              // Inserting the content into the current slot table then we need to
              // update the virtual node counts. Otherwise, we are inserting into
              // a new slot table which is being created, not updated, so the virtual
              // node counts do not need to be updated.
              val group = slotTable.anchorIndex(anchor)
              updateNodeCount(group, updatedNodeCount(group) + nodesToInsert.size)
            }
          }

          // Copy the slot table into the anchor location
          changeListWriter.copySlotTableToAnchorLocation(
            resolvedState = resolvedState,
            parentContext = parentContext,
            from = from,
            to = to,
          )

          fromTable.read { reader ->
            withReader(reader) {
              val newLocation = fromTable.anchorIndex(fromAnchor)
              reader.reposition(newLocation)
              changeListWriter.moveReaderToAbsolute(newLocation)
              val offsetChanges = ChangeList()
              changeListWriter.withChangeList(offsetChanges) {
                changeListWriter.withoutImplicitRootStart {
                  from.transferPendingInvalidations()
                  recomposeMovableContent(
                    from = from.composition,
                    to = to.composition,
                    reader.currentGroup,
                    invalidations = from.invalidations,
                  ) {
                    invokeMovableContentLambda(
                      to.content,
                      to.locals,
                      to.parameter,
                      force = true,
                    )
                  }
                }
              }
              changeListWriter.includeOperationsIn(
                other = offsetChanges,
                effectiveNodeIndex = effectiveNodeIndex,
              )
            }
          }
        }
        changeListWriter.skipToEndOfCurrentGroup()
      }
      changeListWriter.endMovableContentPlacement()
      changeListWriter.moveReaderToAbsolute(0)
    }
  }

  private inline fun <R> withReader(reader: SlotReader, block: () -> R): R {
    val savedReader = this.reader
    val savedCountOverrides = nodeCountOverrides
    val savedProviderUpdates = providerUpdates
    nodeCountOverrides = null
    providerUpdates = null
    try {
      this.reader = reader
      return block()
    } finally {
      this.reader = savedReader
      nodeCountOverrides = savedCountOverrides
      providerUpdates = savedProviderUpdates
    }
  }

  private fun <R> recomposeMovableContent(
    from: ControlledComposition? = null,
    to: ControlledComposition? = null,
    index: Int? = null,
    invalidations: List<Pair<RecomposeScopeImpl, Any?>> = emptyList(),
    block: () -> R,
  ): R {
    val savedIsComposing = isComposing
    val savedNodeIndex = nodeIndex
    try {
      isComposing = true
      nodeIndex = 0
      invalidations.fastForEach { (scope, instances) ->
        if (instances != null) {
          tryImminentInvalidation(scope, instances)
        } else {
          tryImminentInvalidation(scope, null)
        }
      }
      return from?.delegateInvalidations(to, index ?: -1, block) ?: block()
    } finally {
      isComposing = savedIsComposing
      nodeIndex = savedNodeIndex
    }
  }

  @ComposeCompilerApi
  override fun sourceInformation(sourceInformation: String) {
    if (inserting && sourceMarkersEnabled) {
      writer.recordGroupSourceInformation(sourceInformation)
    }
  }

  @ComposeCompilerApi
  override fun sourceInformationMarkerStart(key: Int, sourceInformation: String) {
    if (inserting && sourceMarkersEnabled) {
      writer.recordGrouplessCallSourceInformationStart(key, sourceInformation)
    }
  }

  @ComposeCompilerApi
  override fun sourceInformationMarkerEnd() {
    if (inserting && sourceMarkersEnabled) {
      writer.recordGrouplessCallSourceInformationEnd()
    }
  }

  override fun disableSourceInformation() {
    sourceMarkersEnabled = false
  }

  internal fun stackTraceForValue(value: Any?): List<ComposeStackTraceFrame> {
    if (!sourceMarkersEnabled) return emptyList()

    return slotTable
      .findLocation { it === value || (it as? RememberObserverHolder)?.wrapped === value }
      ?.let { (groupIndex, dataIndex) ->
        stackTraceForGroup(groupIndex, dataIndex) + parentStackTrace()
      } ?: emptyList()
  }

  private fun currentStackTrace(): List<ComposeStackTraceFrame> {
    if (!sourceMarkersEnabled) return emptyList()

    val trace = mutableListOf<ComposeStackTraceFrame>()
    trace.addAll(writer.buildTrace())
    trace.addAll(reader.buildTrace())

    return trace.apply { addAll(parentStackTrace()) }
  }

  private fun stackTraceForGroup(group: Int, dataOffset: Int?): List<ComposeStackTraceFrame> {
    if (!sourceMarkersEnabled) return emptyList()

    return slotTable.read { it.traceForGroup(group, dataOffset) }
  }

  fun parentStackTrace(): List<ComposeStackTraceFrame> {
    val parentComposition = parentContext.composition as? CompositionImpl ?: return emptyList()
    val position = parentComposition.slotTable.findSubcompositionContextGroup(parentContext)

    return if (position != null) {
      parentComposition.slotTable.read { reader -> reader.traceForGroup(position, 0) } +
        parentComposition.composer.parentStackTrace()
    } else {
      emptyList()
    }
  }

  /**
   * Synchronously compose the initial composition of [content]. This collects all the changes
   * which must be applied by [ControlledComposition.applyChanges] to build the tree implied by
   * [content].
   */
  internal fun composeContent(
    invalidationsRequested: ScopeMap<RecomposeScopeImpl, Any>,
    content: @Composable () -> Unit,
    shouldPause: ShouldPauseCallback?,
  ) {
    runtimeCheck(changes.isEmpty()) { "Expected applyChanges() to have been called" }
    this.shouldPauseCallback = shouldPause
    try {
      doCompose(invalidationsRequested, content)
    } finally {
      this.shouldPauseCallback = null
    }
  }

  internal fun prepareCompose(block: () -> Unit) {
    runtimeCheck(!isComposing) { "Preparing a composition while composing is not supported" }
    isComposing = true
    try {
      block()
    } finally {
      isComposing = false
    }
  }

  /**
   * Synchronously recompose all invalidated groups. This collects the changes which must be
   * applied by [ControlledComposition.applyChanges] to have an effect.
   */
  internal fun recompose(
    invalidationsRequested: ScopeMap<RecomposeScopeImpl, Any>,
    shouldPause: ShouldPauseCallback?,
  ): Boolean {
    runtimeCheck(changes.isEmpty()) { "Expected applyChanges() to have been called" }
    // even if invalidationsRequested is empty we still need to recompose if the Composer has
    // some invalidations scheduled already. it can happen when during some parent composition
    // there were a change for a state which was used by the child composition. such changes
    // will be tracked and added into `invalidations` list.
    if (invalidationsRequested.size > 0 || invalidations.isNotEmpty() || forciblyRecompose) {
      shouldPauseCallback = shouldPause
      try {
        doCompose(invalidationsRequested, null)
      } finally {
        shouldPauseCallback = null
      }
      return changes.isNotEmpty()
    }
    return false
  }

  fun updateComposerInvalidations(invalidationsRequested: ScopeMap<RecomposeScopeImpl, Any>) {
    // Update any invalidations that have may have moved since they were added, removing any
    // that are no longer in the slot table.
    for (i in invalidations.lastIndex downTo 0) {
      val invalidation = invalidations[i]
      val anchor = invalidation.scope.anchor
      if (anchor != null && anchor.valid) {
        if (invalidation.location != anchor.location)
          invalidation.location = anchor.location
      } else {
        invalidations.removeAt(i)
      }
    }

    // Add the requested invalidations
    invalidationsRequested.map.forEach { scope, instances ->
      scope as RecomposeScopeImpl
      val location = scope.anchor?.location ?: return@forEach
      invalidations.add(
        Invalidation(scope, location, instances.takeUnless { it === ScopeInvalidated })
      )
    }

    // Ensure the invalidations are in sorted order.
    invalidations.sortWith(InvalidationLocationAscending)
  }

  private fun doCompose(
    invalidationsRequested: ScopeMap<RecomposeScopeImpl, Any>,
    content: (@Composable () -> Unit)?,
  ) {
    runtimeCheck(!isComposing) { "Reentrant composition is not supported" }
    val observer = observerHolder.current()
    trace("Compose:recompose") {
      compositionToken = currentSnapshot().snapshotId.hashCode()
      providerUpdates = null
      updateComposerInvalidations(invalidationsRequested)
      nodeIndex = 0
      var complete = false
      isComposing = true
      observer?.onBeginComposition(composition)
      try {
        startRoot()

        // vv Experimental for forced
        val savedContent = nextSlot()
        if (savedContent !== content && content != null) {
          updateValue(content as Any?)
        }
        // ^^ Experimental for forced

        // Ignore reads of derivedStateOf recalculations
        observeDerivedStateRecalculations(derivedStateObserver) {
          if (content != null) {
            startGroup(invocationKey, invocation)
            invokeComposable(this, content)
            endGroup()
          } else if (
            (forciblyRecompose || providersInvalid) &&
            savedContent != null &&
            savedContent != Composer.Empty
          ) {
            startGroup(invocationKey, invocation)
            @Suppress("UNCHECKED_CAST")
            invokeComposable(this, savedContent as @Composable () -> Unit)
            endGroup()
          } else {
            skipCurrentGroup()
          }
        }
        endRoot()
        complete = true
      } catch (e: Throwable) {
        throw e.attachComposeStackTrace { currentStackTrace() }
      } finally {
        observer?.onEndComposition(composition)
        isComposing = false
        invalidations.clear()
        if (!complete) abortRoot()
        createFreshInsertTable()
      }
    }
  }

  @Suppress("unused")
  val hasInvalidations: Boolean
    get() = invalidations.isNotEmpty()

  private val SlotReader.node: Any?
    get() = node(index = parent)

  private fun SlotReader.nodeAt(index: Int): Any? = node(index = index)

  private fun validateNodeExpected() {
    runtimeCheck(nodeExpected) {
      // createNode(), emitNode() 또는 useNode() 호출이 예상되었으나 호출되지 않았습니다.
      "A call to createNode(), emitNode() or useNode() expected was not expected"
    }

    nodeExpected = false
  }

  private fun validateNodeNotExpected() {
    runtimeCheck(!nodeExpected) {
      // createNode(), emitNode() 또는 useNode() 호출이 예상되었습니다.
      "A call to createNode(), emitNode() or useNode() expected"
    }
  }

  private fun recordInsert(anchor: Anchor) {
    if (insertFixups.isEmpty()) {
      changeListWriter.insertSlots(anchor = anchor, from = insertTable)
    } else {
      changeListWriter.insertSlots(
        anchor = anchor,
        from = insertTable,
        fixups = insertFixups,
      )
      insertFixups = FixupList()
    }
  }

  private fun recordDelete() {
    // It is import that the movable content is reported first so it can be removed before the
    // group itself is removed.
    //
    // 이동 가능한 콘텐츠는 그룹 자체가 제거되기 전에 먼저 제거될 수 있도록 우선 보고하는 것이
    // 중요합니다.
    reportFreeMovableContent(groupBeingRemoved = reader.currentGroup)
    changeListWriter.removeCurrentGroup()
  }

  /**
   * Report any movable content that the group contains as being removed and ready to be moved.
   * Returns true if the group itself was removed.
   *
   * Returns the number of nodes left in place which is used to calculate the node index of any
   * nested calls.
   *
   * @param groupBeingRemoved The group that is being removed from the table or 0 if the entire
   *   table is being removed.
   *
   *
   * 그룹에 포함된 movable 콘텐츠가 제거되었고 이동할 준비가 되었음을 보고합니다. 그룹 자체가
   * 제거되었으면 true를 반환합니다.
   *
   * 자리에 남아 있는 노드의 수를 반환하며, 이는 중첩 호출의 노드 인덱스를 계산하는 데 사용됩니다.
   *
   * @param groupBeingRemoved 제거되는 그룹. 전체 테이블이 제거되는 경우 0입니다.
   */
  private fun reportFreeMovableContent(groupBeingRemoved: Int) {
    fun createMovableContentReferenceForGroup(
      group: Int,
      nestedStates: List<MovableContentStateReference>?,
    ): MovableContentStateReference {
      @Suppress("UNCHECKED_CAST")
      val movableContent = reader.groupObjectKey(group) as MovableContent<Any?>
      val parameter = reader.groupGet(group, 0)
      val anchor = reader.anchor(group)
      val end = group + reader.groupSize(group)
      val invalidations = mutableListOf<Pair<RecomposeScopeImpl, Any?>>()
      this.invalidations.forEachInRange(group, end) {
        invalidations += it.scope to it.instances
      }
      val reference =
        MovableContentStateReference(
          movableContent,
          parameter,
          composition,
          slotTable,
          anchor,
          invalidations,
          currentCompositionLocalScope(group),
          nestedStates,
        )
      return reference
    }

    fun movableContentReferenceFor(group: Int): MovableContentStateReference? {
      val key = reader.groupKey(group)
      val objectKey = reader.groupObjectKey(group)
      return if (key == movableContentKey && objectKey is MovableContent<*>) {
        val nestedStates =
          if (reader.containsMark(group)) {
            val nestedStates = mutableListOf<MovableContentStateReference>()
            fun traverseGroups(group: Int) {
              val size = reader.groupSize(group)
              val end = group + size
              var current = group + 1
              while (current < end) {
                if (reader.hasMark(current)) {
                  movableContentReferenceFor(current)?.let {
                    nestedStates.add(it)
                  }
                } else if (reader.containsMark(current)) traverseGroups(current)
                current += reader.groupSize(current)
              }
            }
            traverseGroups(group)
            nestedStates.takeIf { it.isNotEmpty() }
          } else null
        createMovableContentReferenceForGroup(group, nestedStates)
      } else null
    }

    fun reportGroup(group: Int, needsNodeDelete: Boolean, nodeIndex: Int): Int {
      val reader = reader
      return if (reader.hasMark(group)) {
        // If the group has a mark then it is either a movable content group or a
        // composition context group
        val key = reader.groupKey(group)
        val objectKey = reader.groupObjectKey(group)
        if (key == movableContentKey && objectKey is MovableContent<*>) {
          // If the group is a movable content block schedule it to be removed and report
          // that it is free to be moved to the parentContext. Nested movable content is
          // recomposed if necessary once the group has been claimed by another insert.
          // reportMovableContentForGroup(group)
          // reportMovableContentAt(group)
          val reference = movableContentReferenceFor(group)
          if (reference != null) {
            parentContext.deletedMovableContent(reference)
            changeListWriter.recordSlotEditing()
            changeListWriter.releaseMovableGroupAtCurrent(
              composition,
              parentContext,
              reference,
            )
          }
          if (needsNodeDelete && group != groupBeingRemoved) {
            changeListWriter.endNodeMovementAndDeleteNode(nodeIndex, group)
            0 // These nodes were deleted
          } else reader.nodeCount(group)
        } else if (key == referenceKey && objectKey == reference) {
          // Group is a composition context reference. As this is being removed assume
          // all movable groups in the composition that have this context will also be
          // released when the compositions are disposed.
          val observerHolder = reader.groupGet(group, 0) as? RememberObserverHolder
          val contextHolder = observerHolder?.wrapped as? CompositionContextHolder
          if (contextHolder != null) {
            // The contextHolder can be EMPTY in cases where the content has been
            // deactivated. Content is deactivated if the content is just being
            // held onto for recycling and is not otherwise active. In this case
            // the composers we are likely to find here have already been disposed.
            val compositionContext = contextHolder.ref
            compositionContext.composers.forEach { composer ->
              composer.reportAllMovableContent()

              // Mark the composition as being removed so it will not be recomposed
              // this turn.
              parentContext.reportRemovedComposition(composer.composition)
            }
          }
          reader.nodeCount(group)
        } else if (reader.isNode(group)) 1 else reader.nodeCount(group)
      } else if (reader.containsMark(group)) {
        // Traverse the group freeing the child movable content. This group is known to
        // have at least one child that contains movable content because the group is
        // marked as containing a mark
        val size = reader.groupSize(group)
        val end = group + size
        var current = group + 1
        var runningNodeCount = 0
        while (current < end) {
          // A tree is not disassembled when it is removed, the root nodes of the
          // sub-trees are removed, therefore, if we enter a node that contains movable
          // content, the nodes should be removed so some future composition can
          // re-insert them at a new location. Otherwise the applier will attempt to
          // insert a node that already has a parent. If there is no node between the
          // group removed and this group then the nodes will be removed by normal
          // recomposition.
          val isNode = reader.isNode(current)
          if (isNode) {
            changeListWriter.endNodeMovement()
            changeListWriter.moveDown(reader.node(current))
          }
          runningNodeCount +=
            reportGroup(
              group = current,
              needsNodeDelete = isNode || needsNodeDelete,
              nodeIndex = if (isNode) 0 else nodeIndex + runningNodeCount,
            )
          if (isNode) {
            changeListWriter.endNodeMovement()
            changeListWriter.moveUp()
          }
          current += reader.groupSize(current)
        }
        if (reader.isNode(group)) 1 else runningNodeCount
      } else if (reader.isNode(group)) 1 else reader.nodeCount(group)
    }

    // If the group that is being deleted is a node we need to remove any children that
    // are moved.
    val rootIsNode = reader.isNode(groupBeingRemoved)
    if (rootIsNode) {
      changeListWriter.endNodeMovement()
      changeListWriter.moveDown(reader.node(groupBeingRemoved))
    }
    reportGroup(groupBeingRemoved, needsNodeDelete = rootIsNode, nodeIndex = 0)
    changeListWriter.endNodeMovement()
    if (rootIsNode) {
      changeListWriter.moveUp()
    }
  }

  /**
   * Called during composition to report all the content of the composition will be released as
   * this composition is to be disposed.
   */
  private fun reportAllMovableContent() {
    if (slotTable.containsMark()) {
      composition.updateMovingInvalidations()
      val changes = ChangeList()
      deferredChanges = changes
      slotTable.read { reader ->
        this.reader = reader
        changeListWriter.withChangeList(changes) {
          reportFreeMovableContent(0)
          changeListWriter.releaseMovableContent()
        }
      }
    }
  }

  private fun finalizeCompose() {
    changeListWriter.finalizeComposition()
    runtimeCheck(pendingStack.isEmpty()) { "Start/end imbalance" }
    cleanUpCompose()
  }

  private fun cleanUpCompose() {
    pending = null
    nodeIndex = 0
    groupNodeCount = 0
    compositeKeyHashCode = EmptyCompositeKeyHashCode
    nodeExpected = false
    changeListWriter.resetTransientState()
    invalidateStack.clear()
    clearUpdatedNodeCounts()
  }

  internal fun verifyConsistent() {
    insertTable.verifyWellFormed()
  }

  /**
   * A holder that will dispose of its [CompositionContext] when it leaves the composition that
   * will not have its reference made visible to user code.
   */
  internal class CompositionContextHolder(val ref: CompositionContextImpl) : RememberObserver {

    override fun onRemembered() {}

    override fun onAbandoned() {
      ref.dispose()
    }

    override fun onForgotten() {
      ref.dispose()
    }
  }

  @OptIn(ExperimentalComposeRuntimeApi::class)
  internal inner class CompositionContextImpl(
    override val compositeKeyHashCode: CompositeKeyHashCode,
    override val collectingParameterInformation: Boolean,
    override val collectingSourceInformation: Boolean,
    override val observerHolder: CompositionObserverHolder?,
  ) : CompositionContext() {
    var inspectionTables: MutableSet<MutableSet<CompositionData>>? = null
    val composers = mutableSetOf<ComposerImpl>()

    override val collectingCallByInformation: Boolean
      get() = parentContext.collectingCallByInformation

    fun dispose() {
      if (composers.isNotEmpty()) {
        inspectionTables?.let {
          for (composer in composers) {
            for (table in it) table.remove(composer.compositionData)
          }
        }
        composers.clear()
      }
    }

    override fun registerComposer(composer: Composer) {
      super.registerComposer(composer as ComposerImpl)
      composers.add(composer)
    }

    override fun unregisterComposer(composer: Composer) {
      inspectionTables?.forEach { it.remove((composer as ComposerImpl).compositionData) }
      composers.remove(composer)
    }

    override fun registerComposition(composition: ControlledComposition) {
      parentContext.registerComposition(composition)
    }

    override fun unregisterComposition(composition: ControlledComposition) {
      parentContext.unregisterComposition(composition)
    }

    override fun reportPausedScope(scope: RecomposeScopeImpl) {
      parentContext.reportPausedScope(scope)
    }

    override val effectCoroutineContext: CoroutineContext
      get() = parentContext.effectCoroutineContext

    @OptIn(ExperimentalComposeApi::class)
    override val recomposeCoroutineContext: CoroutineContext
      get() = this@ComposerImpl.composition.recomposeCoroutineContext

    override fun composeInitial(
      composition: ControlledComposition,
      content: @Composable () -> Unit,
    ) {
      parentContext.composeInitial(composition, content)
    }

    override fun composeInitialPaused(
      composition: ControlledComposition,
      shouldPause: ShouldPauseCallback,
      content: @Composable () -> Unit,
    ): ScatterSet<RecomposeScopeImpl> =
      parentContext.composeInitialPaused(composition, shouldPause, content)

    override fun recomposePaused(
      composition: ControlledComposition,
      shouldPause: ShouldPauseCallback,
      invalidScopes: ScatterSet<RecomposeScopeImpl>,
    ): ScatterSet<RecomposeScopeImpl> =
      parentContext.recomposePaused(composition, shouldPause, invalidScopes)

    override fun invalidate(composition: ControlledComposition) {
      // Invalidate ourselves with our parent before we invalidate a child composer.
      // This ensures that when we are scheduling recompositions, parents always
      // recompose before their children just in case a recomposition in the parent
      // would also cause other recomposition in the child.
      // If the parent ends up having no real invalidations to process we will skip work
      // for that composer along a fast path later.
      // This invalidation process could be made more efficient as it's currently N^2 with
      // subcomposition meta-tree depth thanks to the double recursive parent walk
      // performed here, but we currently assume a low N.
      parentContext.invalidate(this@ComposerImpl.composition)
      parentContext.invalidate(composition)
    }

    override fun invalidateScope(scope: RecomposeScopeImpl) {
      parentContext.invalidateScope(scope)
    }

    // This is snapshot state not because we need it to be observable, but because
    // we need changes made to it in composition to be visible for the rest of the current
    // composition and not become visible outside of the composition process until composition
    // succeeds.
    private var compositionLocalScope by
    mutableStateOf<PersistentCompositionLocalMap>(
      persistentCompositionLocalHashMapOf(),
      referentialEqualityPolicy(),
    )

    override fun getCompositionLocalScope(): PersistentCompositionLocalMap =
      compositionLocalScope

    fun updateCompositionLocalScope(scope: PersistentCompositionLocalMap) {
      compositionLocalScope = scope
    }

    override fun recordInspectionTable(table: MutableSet<CompositionData>) {
      (inspectionTables
        ?: HashSet<MutableSet<CompositionData>>().also { inspectionTables = it })
        .add(table)
    }

    override fun startComposing() {
      childrenComposing++
    }

    override fun doneComposing() {
      childrenComposing--
    }

    override fun insertMovableContent(reference: MovableContentStateReference) {
      parentContext.insertMovableContent(reference)
    }

    override fun deletedMovableContent(reference: MovableContentStateReference) {
      parentContext.deletedMovableContent(reference)
    }

    override fun movableContentStateResolve(
      reference: MovableContentStateReference,
    ): MovableContentState? = parentContext.movableContentStateResolve(reference)

    override fun movableContentStateReleased(
      reference: MovableContentStateReference,
      data: MovableContentState,
      applier: Applier<*>,
    ) {
      parentContext.movableContentStateReleased(reference, data, applier)
    }

    override fun reportRemovedComposition(composition: ControlledComposition) {
      parentContext.reportRemovedComposition(composition)
    }

    override val composition: Composition
      get() = this@ComposerImpl.composition

    override fun scheduleFrameEndCallback(action: () -> Unit): CancellationHandle {
      return parentContext.scheduleFrameEndCallback(action)
    }
  }

  private inline fun updateCompositeKeyWhenWeEnterGroup(
    groupKey: Int,
    rGroupIndex: Int,
    dataKey: Any?,
    data: Any?,
  ) {
    if (dataKey == null) {
      if (data != null && groupKey == reuseKey && data != Composer.Empty) {
        updateCompositeKeyWhenWeEnterGroupKeyHash(
          groupKey = data.hashCode(),
          rGroupIndex = rGroupIndex,
        )
      } else {
        updateCompositeKeyWhenWeEnterGroupKeyHash(
          groupKey = groupKey,
          rGroupIndex = rGroupIndex,
        )
      }
    }

    // dataKey != null
    else if (dataKey is Enum<*>) {
      updateCompositeKeyWhenWeEnterGroupKeyHash(
        groupKey = dataKey.ordinal,
        rGroupIndex = 0,
      )
    }

    // dataKey != null && dataKey !is Enum<*>
    else {
      updateCompositeKeyWhenWeEnterGroupKeyHash(
        groupKey = dataKey.hashCode(),
        rGroupIndex = 0,
      )
    }
  }

  private inline fun updateCompositeKeyWhenWeEnterGroupKeyHash(groupKey: Int, rGroupIndex: Int) {
    compositeKeyHashCode =
      compositeKeyHashCode
        .compoundWith(segment = groupKey, shift = 3)
        .compoundWith(segment = rGroupIndex, shift = 3)
  }

  private inline fun updateCompositeKeyWhenWeExitGroup(
    groupKey: Int,
    rGroupIndex: Int,
    dataKey: Any?,
    data: Any?,
  ) {
    if (dataKey == null) {
      if (data != null && groupKey == reuseKey && data != Composer.Empty) {
        updateCompositeKeyWhenWeExitGroupKeyHash(
          groupKey = data.hashCode(),
          rGroupIndex = rGroupIndex,
        )
      } else {
        updateCompositeKeyWhenWeExitGroupKeyHash(
          groupKey = groupKey,
          rGroupIndex = rGroupIndex,
        )
      }
    } else if (dataKey is Enum<*>) {
      updateCompositeKeyWhenWeExitGroupKeyHash(
        groupKey = dataKey.ordinal,
        rGroupIndex = 0,
      )
    } else {
      updateCompositeKeyWhenWeExitGroupKeyHash(
        groupKey = dataKey.hashCode(),
        rGroupIndex = 0,
      )
    }
  }

  private inline fun updateCompositeKeyWhenWeExitGroupKeyHash(groupKey: Int, rGroupIndex: Int) {
    compositeKeyHashCode =
      compositeKeyHashCode
        .unCompoundWith(segment = rGroupIndex, shift = 3)
        .unCompoundWith(segment = groupKey, shift = 3)
  }

  // This is only used in tests to ensure the stacks do not silently leak.
  // 이것은 스택이 조용히 누수되지 않음을 확인하기 위해 테스트에서만 사용됩니다.
  @TestOnly internal fun stacksSize(): Int =
    entersStack.size +
      invalidateStack.size +
      providersInvalidStack.size +
      pendingStack.size +
      parentStateStack.size

  override val recomposeScope: RecomposeScope?
    get() = currentRecomposeScope

  override val recomposeScopeIdentity: Any?
    get() = currentRecomposeScope?.anchor

  override fun rememberedValue(): Any? = nextSlotForCache()

  override fun updateRememberedValue(value: Any?) = updateCachedValue(value)

  override fun recordUsed(scope: RecomposeScope) {
    (scope as? RecomposeScopeImpl)?.used = true
  }
}

internal fun SlotWriter.deactivateCurrentGroup(rememberManager: RememberManager) {
  // Notify the lifecycle manager of any observers leaving the slot table
  // The notification order should ensure that listeners are notified of leaving
  // in opposite order that they are notified of entering.

  // To ensure this order, we call `enters` as a pre-order traversal
  // of the group tree, and then call `leaves` in the inverse order.
  forAllDataInRememberOrder(currentGroup) { slotIndex, data ->
    when (data) {
      is ComposeNodeLifecycleCallback -> {
        rememberManager.deactivating(data)
      }
      is ReusableRememberObserverHolder -> {
        // do nothing, the value should be preserved on reuse
      }
      is RememberObserverHolder -> {
        removeData(slotIndex, data)
        rememberManager.forgetting(data)
      }
      is RecomposeScopeImpl -> {
        removeData(slotIndex, data)
        data.release()
      }
    }
  }
}

private fun SlotWriter.removeData(index: Int, data: Any?) {
  val result = clear(index)
  runtimeCheck(data === result) { "Slot table is out of sync (expected $data, got $result)" }
}

private fun <K : Any, V : Any> multiMap(initialCapacity: Int) =
  MultiValueMap<K, V>(MutableScatterMap(initialCapacity))

private fun getKey(value: Any?, left: Any?, right: Any?): Any? =
  (value as? JoinedKey)?.let {
    if (it.left == left && it.right == right) value
    else getKey(it.left, left, right) ?: getKey(it.right, left, right)
  }

// Invalidation helpers
private fun List<Invalidation>.findLocation(location: Int): Int {
  var low = 0
  var high = size - 1

  while (low <= high) {
    val mid = (low + high).ushr(1) // safe from overflows
    val midVal = get(mid)
    val cmp = midVal.location.compareTo(location)

    when {
      cmp < 0 -> low = mid + 1
      cmp > 0 -> high = mid - 1
      else -> return mid // key found
    }
  }
  return -(low + 1) // key not found
}

private fun List<Invalidation>.findInsertLocation(location: Int): Int =
  findLocation(location).let { if (it < 0) -(it + 1) else it }

private fun MutableList<Invalidation>.insertIfMissing(
  location: Int,
  scope: RecomposeScopeImpl,
  instance: Any?,
) {
  val index = findLocation(location)
  if (index < 0) {
    add(
      -(index + 1),
      Invalidation(
        scope,
        location,
        // Only derived state instance is important for composition
        instance.takeIf { it is DerivedState<*> },
      ),
    )
  } else {
    val invalidation = get(index)
    // Only derived state instance is important for composition
    if (instance is DerivedState<*>) {
      when (val oldInstance = invalidation.instances) {
        null -> {
          invalidation.instances = instance
        }
        is MutableScatterSet<*> -> {
          @Suppress("UNCHECKED_CAST")
          oldInstance as MutableScatterSet<Any?>
          oldInstance.add(instance)
        }
        else -> {
          invalidation.instances = mutableScatterSetOf(oldInstance, instance)
        }
      }
    } else {
      invalidation.instances = null
    }
  }
}

private fun MutableList<Invalidation>.firstInRange(start: Int, end: Int): Invalidation? {
  val index = findInsertLocation(start)
  if (index < size) {
    val firstInvalidation = get(index)
    if (firstInvalidation.location < end) return firstInvalidation
  }
  return null
}

private fun MutableList<Invalidation>.removeLocation(location: Int): Invalidation? {
  val index = findLocation(location)
  return if (index >= 0) removeAt(index) else null
}

private fun MutableList<Invalidation>.removeRange(start: Int, end: Int) {
  val index = findInsertLocation(start)
  while (index < size) {
    val validation = get(index)
    if (validation.location < end) removeAt(index) else break
  }
}

private inline fun List<Invalidation>.forEachInRange(
  start: Int,
  end: Int,
  block: (Invalidation) -> Unit,
) {
  var index = findInsertLocation(start)
  while (index < size) {
    val invalidation = get(index)
    if (invalidation.location >= end) break

    block(invalidation)
    index++
  }
}

internal fun Boolean.asInt(): Int = if (this) 1 else 0

private fun Int.asBool() = this != 0

private fun SlotTable.collectNodesFrom(anchor: Anchor): List<Any?> {
  val result = mutableListOf<Any?>()
  read { reader ->
    val index = anchorIndex(anchor)
    fun collectFromGroup(group: Int) {
      if (reader.isNode(group)) {
        result.add(reader.node(group))
      } else {
        var current = group + 1
        val end = group + reader.groupSize(group)
        while (current < end) {
          collectFromGroup(current)
          current += reader.groupSize(current)
        }
      }
    }
    collectFromGroup(index)
  }
  return result
}

private fun SlotReader.distanceFrom(index: Int, root: Int): Int {
  var count = 0
  var current = index
  while (current > 0 && current != root) {
    current = parent(current)
    count++
  }
  return count
}

// 여기서 쓰인 알고리즘은 최소 공통 조상(LCA, Lowest Common Ancestor) 탐색 알고리즘이에요.
//
// ⸻
//
// 핵심 아이디어
// 	•	두 노드(aGroup, bGroup)가 주어졌을 때, 이들이 속한 트리 구조에서 가장 가까운 공통 조상을
// 	  찾는 문제.
// 	•	코드에서는 parent(index) 함수를 통해 트리 위로 거슬러 올라갈 수 있고, distanceFrom을 이용해
// 	  특정 루트까지의 깊이(depth)를 계산해요.
//
// ⸻
//
// 알고리즘 절차
//
// 	1.	빠른 종료 케이스(Early out)
// 	•	두 노드가 동일한 경우 → 자기 자신이 LCA
// 	•	하나가 공통 루트인 경우 → 공통 루트 반환
// 	•	한쪽이 다른 쪽의 부모인 경우 → 부모를 반환
// 	•	둘이 같은 부모를 공유하면 → 그 부모가 LCA
//
// 	2.	깊이 맞추기
// 	•	distanceFrom(aGroup, common)과 distanceFrom(bGroup, common)으로 각 노드가 common 루트까지
// 	  얼마나 떨어져 있는지 계산
// 	•	깊이가 더 깊은 쪽을 부모로 올려서 두 노드를 같은 높이로 맞춤
//
// 	3.	조상 찾기
// 	•	같은 깊이에서 동시에 부모를 따라 올라감
// 	•	처음 만나는 동일한 노드가 LCA
//
// ⸻
//
// 성격
// 	•	전형적인 Depth Alignment + Parent Climb 방식의 LCA 탐색
// 	•	전처리(예: Binary Lifting, Tarjan Offline 알고리즘)는 쓰지 않고, 단순히 깊이를 맞춘 후 위로
// 	  올라가는 방식이라 시간 복잡도는 O(h) (h = 트리 높이)
//
// ⸻
//
// 정리하면, 이 코드는 “트리에서 두 노드의 최소 공통 조상을 찾는 알고리즘(LCA)” 이고, 구현 방식은
// 깊이 차이를 맞춘 뒤 동시에 부모로 올라가며 탐색하는 기본형 LCA 알고리즘이에요.

// find the nearest common root.
// 가장 가까운 공통 루트를 찾습니다.
//
// MEMO 최소 공통 조상 알고리즘! 나 예전에 공부했던 거다 ㅎㅎ.
private fun SlotReader.nearestCommonRootOf(aGroup: Int, bGroup: Int, common: Int): Int {
  // Early outs, to avoid calling distanceFrom in trivial cases.

  if (aGroup == bGroup) return aGroup // A group is the nearest common root of itself.
  if (aGroup == common || bGroup == common) return common // If either is common then common is nearest.
  if (parent(aGroup) == bGroup) return bGroup // if b is a's parent b is the nearest common root.
  if (parent(bGroup) == aGroup) return aGroup // if a is b's parent a is the nearest common root.
  if (parent(aGroup) == parent(bGroup)) return parent(aGroup) // if a an b share a parent it is common.

  // Find the nearest using distance from common.
  var currentA = aGroup
  var currentB = bGroup
  val aDistance = distanceFrom(aGroup, common)
  val bDistance = distanceFrom(bGroup, common)

  repeat(aDistance - bDistance) { currentA = parent(currentA) }
  repeat(bDistance - aDistance) { currentB = parent(currentB) }

  // Both ca and cb are now the same distance from a known common root,
  // therefore, the first parent that is the same is the lowest common root.
  while (currentA != currentB) {
    currentA = parent(currentA)
    currentB = parent(currentB)
  }

  // ca == cb so it doesn't matter which is returned.
  return currentA
}

private val KeyInfo.joinedKey: Any
  get() =
    if (objectKey != null)
      JoinedKey(left = key, right = objectKey)
    else
      key

/**
 * Group types used with [Composer.start] to differentiate between different types of groups.
 *
 * [Composer.start]에서 사용하는 그룹 타입으로, 서로 다른 그룹 종류를 구분하는 데 사용합니다.
 */
@JvmInline private value class GroupKind private constructor(val value: Int) {
  inline val isNode: Boolean
    get() = value != Group.value

  inline val isReusable: Boolean
    get() = value != Node.value

  companion object {
    val Group = GroupKind(0)
    val Node = GroupKind(1)
    val ReusableNode = GroupKind(2)
  }
}

private val InvalidationLocationAscending: Comparator<Invalidation> =
  Comparator { i1, i2 -> i1.location.compareTo(i2.location) }

/*
 * Integer keys are arbitrary values in the biload range. The do not need to be unique as if
 * there is a chance they will collide with a compiler generated key they are paired with a
 * OpaqueKey to ensure they are unique.
 *
 * 정수 키는 biload 범위 내의 임의 값입니다. 컴파일러가 생성한 키와 충돌할 가능성이 있으면,
 * 고유성을 보장하기 위해 OpaqueKey와 함께 사용하므로 고유할 필요가 없습니다.
 */

// rootKey doesn't need a corresponding OpaqueKey as it never has sibling nodes and will always
// a unique key.
//
// rootKey는 형제 노드를 가지지 않으며 항상 고유한 키이므로, OpaqueKey와 대응될 필요가 없습니다.
private const val rootKey = 100

// An arbitrary key value for a node.
// 노드에 대한 임의의 키 값입니다.
private const val nodeKey = 125
